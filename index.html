<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Predicciones Copa Mundial de Clubes 2025</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="container">
    <header class="header">
      <div class="header-content">
        <img src="k-logo.svg" alt="KingMakers" class="logo"/>
        <h1 class="main-title">2025 FIFA Club World Cup Porra</h1>
      </div>
    </header>

    <nav class="nav-tabs">
      <button id="btnClasif" class="tab-button tab-active">
        <span class="tab-icon">üèÜ</span>
        Leaderboard
      </button>
      <button id="btnPred" class="tab-button">
        <span class="tab-icon">‚öΩ</span>
        Predictions
      </button>
    </nav>

    <main class="main-content">
      <section id="predTab" class="tab-content">
        <div class="control-group">
          <label for="participantSelect" class="control-label">Select Participant</label>
          <select id="participantSelect" class="select-input"></select>
        </div>
        <div class="prediction-controls card">
          <div class="leader-extra">
            <div id="leaderSnippet" class="leader-snippet"></div>
            <div id="leaderStats" class="leader-stats"></div>
          </div>
          <h1 id="predTitle" class="section-title"></h1>
        </div>

        <div class="predictions-section">
          <div id="groupStageViewSwitch" class="view-switch" style="margin-bottom:24px; display:flex; gap:8px;">
            <button id="btnViewDate" class="toggle-btn active">By date</button>
            <button id="btnViewGroup" class="toggle-btn">By group</button>
          </div>
          <div id="groupPredHeader" class="section-header collapsible-header">
            <span class="collapse-arrow">‚ñº</span>
            <h3 class="section-title">Group Stage</h3>
            <span class="section-total" id="groupPredTotal"></span>
          </div>
          <div class="table-container">
            <table id="groupPredictionsTable" class="predictions-table">
              <tbody id="groupPredictionsBody"></tbody>
            </table>
          </div>
        </div>

        <section id="standingsSection" class="standings-section" style="display:none;">
          <div id="classifHeader" class="section-header collapsible-header">
            <span class="collapse-arrow">‚ñº</span>
            <h2 class="section-title">Group Classifications</h2>
            <span class="section-total" id="classifTotal"></span>
          </div>
          <div id="standingsContainer" class="standings-grid"></div>
        </section>

        <div class="predictions-section">
          <div id="koPredHeader" class="section-header collapsible-header">
            <span class="collapse-arrow">‚ñº</span>
            <h3 class="section-title">Knockout Stage</h3>
            <span class="section-total" id="koPredTotal"></span>
          </div>
          <div class="table-container">
            <table id="koPredictionsTable" class="predictions-table">
              <tbody id="koPredictionsBody"></tbody>
            </table>
          </div>
        </div>
      </section>

      <section id="clasifTab" class="tab-content" style="display:none;">
          <div class="leaderboard-area">
            <div class="table-container">
              <h3 class="section-title">Overall Leaderboard</h3>
              <p id="updatedAt" class="last-updated"></p>
              <table id="leaderboardTable" class="leaderboard-table">
                <thead>
                  <tr>
                    <th>#</th>
                    <th>Name</th>
                    <th>Pts</th>
                    <th class="progress-header">Form</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
            <div id="globalStats" class="overall-stats"></div>
          </div>
      </section>
    </main>
  </div>

  <script>
    const participantSelect = document.getElementById('participantSelect');
    const btnPred=document.getElementById('btnPred');
    const btnClasif=document.getElementById('btnClasif');
    const predTab=document.getElementById('predTab');
    const clasifTab=document.getElementById('clasifTab');
    const groupPredictionsBody = document.getElementById('groupPredictionsBody');
    const groupPredictionsTable = document.getElementById('groupPredictionsTable');
    const koPredictionsBody = document.getElementById('koPredictionsBody');
    const koPredictionsTable = document.getElementById('koPredictionsTable');
    const standingsContainer = document.getElementById('standingsContainer');
    const standingsSection = document.getElementById('standingsSection');
    const predControls=document.querySelector('.prediction-controls');
    const predTitle=document.getElementById('predTitle');

    let participants = [];
    let leaderboard = [];
    let matchesById = {};
    let predictions = [];
    let groupStandings = {};
    let realGroupStandings = {};
    let resultsById = {};
    let teamIdToName = {};
    let teamIdToBadge = {};
    let currentPredStandings = {}; // clasific. del usuario actual
    let groupPredView = 'date'; // 'date' o 'group'
    let dataLoaded = false;
    let pendingParticipant=null;
    let nameToId = {};
    // Forzar aperturas espec√≠ficas solicitadas
    const FORCE_OPEN_DAYS=['2025-06-26','2025-06-27']; // Fechas que deben mostrarse expandidas en vista "By date"
    const FORCE_OPEN_GROUPS=['G','H']; // Grupos que deben mostrarse expandidos en vistas por grupo y clasificaci√≥n

    function getIdFromToken(tok){
      if(teamIdToBadge[tok]) return tok; // ya es ID
      if(nameToId[tok]) return nameToId[tok]; // es nombre
      // placeholder tipo 1A o 2B usando clasificaci√≥n PRONOSTICADA actual
      if(/^[12][A-H]$/i.test(tok)){
        const pos=parseInt(tok[0],10);
        const grp=tok[1].toUpperCase();
        const arr=currentPredStandings[grp];
        if(arr && arr[pos-1]) return arr[pos-1].teamId;
      }
      return null;
    }

    // Resuelve un token (teamId, nombre, placeholder 1A) al nombre de equipo pronosticado
    function resolveUserToken(token){
      if(teamIdToName[token]) return teamIdToName[token];
      if(/^[12][A-H]$/i.test(token)){
         const pos=parseInt(token[0],10);
         const grp=token[1].toUpperCase();
         const arr=currentPredStandings[grp];
         if(arr && arr[pos-1]) return arr[pos-1].teamName;
      }
      return token;
    }

    async function loadData() {
      try {
        // Cargamos todos los ficheros necesarios en paralelo
        const [participantsRes, matchesRes, predictionsRes, standingsRes, resultsRes, teamsRes] = await Promise.all([
          fetch('participants.json'),
          fetch('matches.json'),
          fetch('predictions.json'),
          fetch('group-standings.json'),
          fetch('results.json'),
          fetch('teams.json')
        ]);

        participants = await participantsRes.json();
        const matchesArray = await matchesRes.json();
        predictions = await predictionsRes.json();
        groupStandings = await standingsRes.json();
        const resultsArray = await resultsRes.json();
        const teamsArray = await teamsRes.json();

        // ùó°ùó®ùóòùó©ùó¢: Recalcular clasificaci√≥n real en base a los √∫ltimos resultados
        realGroupStandings = computeRealGroupStandings(matchesArray, resultsArray, teamsArray);

        // Pasamos los arrays a diccionarios por id para lookup r√°pido
        matchesArray.forEach(m => { matchesById[m.matchId] = m; });
        resultsArray.forEach(r => { resultsById[r.matchId] = r; });

        /* --------------------------------------------------
           Calcular secciones LIVE (al menos un resultado, pero no todos)
        --------------------------------------------------*/
        const calcLive=(matchArr)=>{
          let recorded=0, missing=0;
          matchArr.forEach(m=>{
            const res=resultsById[m.matchId];
            if(res && res.homeGoals!==null && res.awayGoals!==null){ recorded++; } else { missing++; }
          });
          return recorded>0 && missing>0;
        };

        const groupMatches=matchesArray.filter(m=>m.phase==='group');
        const koMatches=matchesArray.filter(m=>m.phase!=='group');

        let liveGroup=false, liveClassif=false, liveKO=false;
        const now=new Date();
        const switchDate=new Date('2025-06-28T00:00:00+02:00'); // 28 Jun 00:00 hora espa√±ola

        if(now < switchDate){
          liveGroup = true;
          liveClassif = true;
          liveKO = false;
        } else {
          liveGroup = false;
          liveClassif = false;
          liveKO = true;
        }

        const setLiveBadge=(headerId,isLive)=>{
          const hdr=document.getElementById(headerId);
          if(!hdr) return;
          let badge=hdr.querySelector('.live-icon');
          if(isLive){
            if(!badge){
              badge=document.createElement('img');
              badge.src='live.svg';
              badge.alt='Live';
              badge.className='badge-icon live-icon';
            }
            const titleEl=hdr.querySelector('.section-title');
            if(titleEl){
              if(titleEl.nextSibling!==badge){ hdr.insertBefore(badge,titleEl.nextSibling); }
            } else {
              hdr.appendChild(badge);
            }
          } else {
            if(badge) badge.remove();
          }
        };

        setLiveBadge('groupPredHeader',liveGroup);
        setLiveBadge('classifHeader',liveClassif);
        setLiveBadge('koPredHeader',liveKO);

        teamIdToName = Object.fromEntries(teamsArray.map(t => [t.teamId, t.name]));
        teamIdToBadge = Object.fromEntries(teamsArray.map(t => [t.teamId, t.badge || '']));

        nameToId = Object.fromEntries(teamsArray.map(t=>[t.name, t.teamId]));

        // ùó°ùó®ùóòùó©ùó¢: Calcular clasificaci√≥n pronosticada para cada participante a partir de sus predicciones
        groupStandings = computeAllPredictedGroupStandings(matchesArray, predictions, teamsArray);

        // Calculamos puntos totales por participante
        // Mapa acumulador de puntos por usuario

        // Helper para resolver tokens seg√∫n predicciones de cada usuario
        function resolveUserTokenFor(uid, token){
          if(teamIdToName[token]) return teamIdToName[token];
          if(/^[12][A-H]$/i.test(token)){
            const pos=parseInt(token[0],10);
            const grp=token[1].toUpperCase();
            const arr=(groupStandings[uid]||{})[grp];
            if(arr){
              const found=arr.find(t=>t.position===pos);
              if(found) return found.teamName;
              if(arr[pos-1]) return arr[pos-1].teamName;
            }
          }
          if(/^W\d+$/i.test(token)){
            const winnerId=getPredictedWinner(uid, token);
            if(winnerId && teamIdToName[winnerId]) return teamIdToName[winnerId];
          }
          return token;
        }

        function resolveRealToken(token){
          if(teamIdToName[token]) return teamIdToName[token];
          if(/^W\d+$/i.test(token)){
            const m=matchesById[token];
            const r=resultsById[token];
            if(m && r && r.homeGoals!==null && r.awayGoals!==null){
              let winnerId=null;
              if(r.homeGoals>r.awayGoals) winnerId=m.homeTeam;
              else if(r.awayGoals>r.homeGoals) winnerId=m.awayTeam;
              else if(r.penalties && r.penalties.homePenaltyGoals!==null && r.penalties.awayPenaltyGoals!==null){
                winnerId = r.penalties.homePenaltyGoals>r.penalties.awayPenaltyGoals ? m.homeTeam : m.awayTeam;
              }
              if(winnerId && teamIdToName[winnerId]) return teamIdToName[winnerId];
            }
          }
          if(/^[12][A-H]$/i.test(token)){
            const pos=parseInt(token[0],10);
            const grp=token[1].toUpperCase();
            const arr=realGroupStandings[grp];
            const groupFinished = arr && arr.every(t=>t.matchesPlayed===3);
            if(groupFinished && arr[pos-1]) return arr[pos-1].teamName;
          }
          return token;
        }

        const pointsByUser = {};
        // Calcular puntos por predicciones de partidos
        predictions.forEach(pred => {
            const pts = calculateMatchPoints(pred);
            pointsByUser[pred.userId]=(pointsByUser[pred.userId]||0)+pts;
        });

        // A√±adimos puntos de clasificaci√≥n de grupos
        Object.keys(groupStandings).forEach(uid=>{
          const userGroups=groupStandings[uid];
          if(!userGroups) return;
          Object.keys(userGroups).forEach(g=>{
            if(isGroupComplete(realGroupStandings[g])){
              const pts=calcGroupPoints(userGroups[g], realGroupStandings[g]);
              pointsByUser[uid]=(pointsByUser[uid]||0)+pts;
            }
          });
        });

        leaderboard = Object.entries(pointsByUser).map(([userId, pts]) => {
          const p = participants.find(pr => pr.userId === userId);
          return { userId, displayName: p ? p.displayName : userId, points: pts };
        }).sort((a, b) => b.points - a.points);

        renderLeaderboard();
        dataLoaded=true;
        if(pendingParticipant!==null){
          displayParticipant(pendingParticipant);
          pendingParticipant=null;
        }

        populateSelect();
        
        // Configurar vista inicial de fase de grupos (por fecha / por grupo)
        const savedView = localStorage.getItem('groupPredView') || 'date';
        setGroupPredView(savedView);

        // Restaurar estado completo de la aplicaci√≥n
        restoreApplicationState();
        
        // Configurar listeners para persistir cambios
        setupStatePersistence();
      } catch (err) {
        console.error('Error cargando datos:', err);
        alert('Hubo un problema cargando los datos. Revisa la consola para m√°s detalles.');
      }
    }

    function populateSelect() {
      // Opci√≥n por defecto vac√≠a
      const defaultOpt=document.createElement('option');
      defaultOpt.value='';
      defaultOpt.textContent='Select a participant...';
      participantSelect.appendChild(defaultOpt);
      // Resto de participantes en orden alfab√©tico
      [...participants].sort((a,b)=> a.displayName.localeCompare(b.displayName,'es',{sensitivity:'base'})).forEach(p => {
        const option = document.createElement('option');
        option.value = p.userId;
        option.textContent = p.displayName;
        participantSelect.appendChild(option);
      });
    }

    function createStandingTable(data) {
        const table = document.createElement('table');
        table.classList.add('group-table');
        
        const thead = document.createElement('thead');
        thead.innerHTML = '<tr><th>Pos</th><th>Team</th><th>MP</th><th>Pts</th><th>GF</th><th>GA</th><th>GD</th></tr>';
        table.appendChild(thead);
        
        const tbody = document.createElement('tbody');
        if (data) {
            data.forEach(team => {
                const tr = document.createElement('tr');
                const badgeImg = teamIdToBadge[team.teamId] ? `<img src="${teamIdToBadge[team.teamId]}" class="team-badge" alt="${team.teamName} badge"/>` : '';
                tr.innerHTML = `<td><span class="position-badge pos-${team.position}">${team.position}</span></td><td class="team-name">${badgeImg}${team.teamName}</td><td>${team.matchesPlayed ?? '-'}</td><td class="points-cell">${team.points}</td><td>${team.goalsFor}</td><td>${team.goalsAgainst}</td><td class="goal-diff ${team.goalDifference > 0 ? 'positive' : team.goalDifference < 0 ? 'negative' : ''}">${team.goalDifference > 0 ? '+' : ''}${team.goalDifference}</td>`;
                tbody.appendChild(tr);
            });
        }
        table.appendChild(tbody);
        return table;
    }

    function displayParticipant(userId) {
      const snippetDiv=document.getElementById('leaderSnippet');
      // Referencias a headings h3 (Grupo y KO)
      const groupSection = document.querySelector('.predictions-section:first-of-type');
      const koSection = document.querySelector('.predictions-section:last-of-type');

      const predSections=document.querySelectorAll('.predictions-section');
      const viewSwitchEl=document.getElementById('groupStageViewSwitch');

      if(!userId){
        // Limpiar y ocultar todo
        groupPredictionsBody.innerHTML='';
        koPredictionsBody.innerHTML='';
        standingsContainer.innerHTML='';
        groupPredictionsTable.style.display='none';
        koPredictionsTable.style.display='none';
        standingsSection.style.display='none';
        if(groupSection) groupSection.style.display='none';
        if(koSection) koSection.style.display='none';
        snippetDiv.innerHTML='';
        if(predTitle){ predTitle.textContent=''; }
        predSections.forEach(sec=> sec.style.display='none');
        if(viewSwitchEl) viewSwitchEl.style.display='none';
        return;
      }

      // Asegurar que elementos est√©n visibles al seleccionar participante
      groupPredictionsTable.style.display='';
      koPredictionsTable.style.display='';
      if(groupSection) groupSection.style.display='';
      if(koSection) koSection.style.display='';
      standingsSection.style.display='block';
      if(viewSwitchEl) viewSwitchEl.style.display='flex';
      
      // Obtener clasificaci√≥n de grupos pronosticada y exponerla para la fase KO
      const userStandings = groupStandings[userId];
      currentPredStandings = userStandings || {};

      // Construimos snippet prev-actual-next
      snippetDiv.innerHTML='';
      if(leaderboard.length && participants.find(p=>p.userId===userId)){
          const idx=leaderboard.findIndex(e=>e.userId===userId);
          const lines=[];
          const makeLine=(entry, bold=false)=>{
              const text=`${entry.rank}¬∫ ${entry.displayName} | ${entry.points} pts`;
              return bold?`<div class="snippet-line current">${text}</div>`:`<div class="snippet-line">${text}</div>`;
          };
          leaderboard.forEach((e,i)=>{ e.rank=i+1; });
          // Determinar cu√°ntas l√≠neas mostrar por encima y por debajo seg√∫n el puesto
          let up=2, down=2;
          if(idx===0){ up=0; down=4; }
          else if(idx===1){ up=1; down=3; }
          else if(idx===16){ up=4; down=0; }


          const start=Math.max(0, idx-up);
          const end=Math.min(leaderboard.length-1, idx+down);

          for(let i=start;i<=end;i++){
            lines.push(makeLine(leaderboard[i], i===idx));
          }
          snippetDiv.innerHTML=lines.join('');
      }

      // 1. Mostramos predicciones de partidos
      const userPreds = predictions.filter(p => p.userId === userId);
      let groupPreds=[];
      let koPreds=[];
      groupPredictionsBody.innerHTML = '';
      koPredictionsBody.innerHTML = '';
      const isPredTabActive = btnPred.classList.contains('tab-active');

      if (userPreds.length > 0) {
        // Ordenamos las predicciones por fecha de partido
        userPreds.sort((a, b) => {
            const dateA = new Date(matchesById[a.matchId]?.dateTime || 0);
            const dateB = new Date(matchesById[b.matchId]?.dateTime || 0);
            return dateA - dateB;
        });

        // Split predictions
        groupPreds = userPreds.filter(p => matchesById[p.matchId]?.phase === 'group');
        koPreds = userPreds.filter(p => matchesById[p.matchId] && matchesById[p.matchId].phase !== 'group');

        // Render group predictions seg√∫n la vista elegida
        if (groupPreds.length>0){
          if(groupPredView==='date'){
            renderPredTable(groupPreds, groupPredictionsBody,false);
          } else {
            renderPredTableGroup(groupPreds, groupPredictionsBody);
          }
        }

        // Render KO predictions SIEMPRE con estilo "By Date" (renderPredTable con isKO=true)
        if(koPreds.length>0){
           renderPredTable(koPreds, koPredictionsBody, true);
           if(koSection) koSection.style.display='';
        } else {
           koPredictionsBody.innerHTML='';
           if(koSection) koSection.style.display='none';
        }

        if(isPredTabActive){
         if(groupPreds.length>0 || koPreds.length>0){ predTab.style.display='block'; } else { predTab.style.display='none'; }
        }
      } else {
        // Si no hay predicciones pero s√≠ usuario, dejamos tablas vac√≠as
        groupPredictionsBody.innerHTML='';
        koPredictionsBody.innerHTML='';
      }
      
      // 2. Mostramos clasificaciones de grupos (predicci√≥n vs real)
      standingsContainer.innerHTML = '';
      const participant = participants.find(p => p.userId === userId);
      const userName = participant ? participant.displayName : userId;

      if (userStandings && Object.keys(realGroupStandings).length > 0) {
        Object.keys(userStandings).sort().forEach(groupKey => {
            const groupCard = document.createElement('div');
            groupCard.className = 'group-card';
            
            // Wrapper de encabezado vertical
            const headerWrap=document.createElement('div');
            headerWrap.className='group-header';

            // Fila superior (t√≠tulo + badge)
            const headerTop=document.createElement('div');
            headerTop.className='header-top';

            const groupTitle=document.createElement('h3');
            groupTitle.className='group-title';
            groupTitle.textContent=`Group ${groupKey}`;
            // Flecha colapsable
            const arrowGrp=document.createElement('span');
            arrowGrp.className='collapse-arrow';
            arrowGrp.textContent='‚ñº';
            headerTop.classList.add('collapsible-header');
            headerTop.appendChild(arrowGrp);
            headerTop.appendChild(groupTitle);

            headerWrap.appendChild(headerTop);
            // Row con badges de los equipos del grupo
            const badgesRow=document.createElement('div');
            badgesRow.className='group-badges';
            const teamsInGroup=realGroupStandings[groupKey] || Object.values(teamIdToName).filter((_,tid)=> teamsArray.find(t=>t.teamId===tid && t.group===groupKey));
            if(teamsInGroup){
              (Array.isArray(teamsInGroup)?teamsInGroup:[]).forEach(t=>{
                const id=t.teamId||t;
                if(teamIdToBadge[id]){
                  const img=document.createElement('img');
                  img.src=teamIdToBadge[id];
                  img.alt=t.teamName||teamIdToName[id]||id;
                  img.className='team-badge';
                  badgesRow.appendChild(img);
                }
              });
            }
            badgesRow.style.marginTop='8px';
            headerWrap.appendChild(badgesRow);

            groupCard.appendChild(headerWrap);

            const tablesContainer = document.createElement('div');
            tablesContainer.className = 'group-tables';

            // Contenedor de dos columnas para Predicci√≥n y Actual
            const twoWrap=document.createElement('div');
            twoWrap.className='tables-wrap';

            // Columna de Predicci√≥n
            const predictedDiv = document.createElement('div');
            predictedDiv.className = 'table-column';
            const predictedTitle = document.createElement('h4');
            predictedTitle.className = 'table-subtitle';
            predictedTitle.textContent = `Prediction (${userName})`;
            predictedDiv.appendChild(predictedTitle);
            predictedDiv.appendChild(createStandingTable(userStandings[groupKey]));
            twoWrap.appendChild(predictedDiv);

            // Columna Real
            const realDiv = document.createElement('div');
            realDiv.className = 'table-column';
            const realTitle = document.createElement('h4');
            realTitle.className = 'table-subtitle';
            realTitle.textContent = 'Actual';
            realDiv.appendChild(realTitle);
            realDiv.appendChild(createStandingTable(realGroupStandings[groupKey]));
            twoWrap.appendChild(realDiv);

            /* Badge de puntos en el header */
            const badge=document.createElement('span');
            badge.className='points-badge';
            let ptsCalc=null;
            if(isGroupComplete(realGroupStandings[groupKey])){
              ptsCalc=calcGroupPoints(userStandings[groupKey], realGroupStandings[groupKey]);
              badge.textContent=`${ptsCalc} pts`;
            } else {
              badge.textContent='-';
            }
            badge.style.marginLeft='8px';
            headerTop.appendChild(badge);

            // Descripci√≥n debajo y alineada derecha
            const ptsDesc=document.createElement('div');
            ptsDesc.className='points-description';
            if(isGroupComplete(realGroupStandings[groupKey])){
              let reason='';
              switch(ptsCalc){
                case 7: reason='Perfect order prediction';break;
                case 5: reason='Both qualifiers correct';break;
                case 2: reason='One qualifier correct';break;
                default: reason='No correct predictions';
              }
              ptsDesc.textContent=reason;
            } else {
              ptsDesc.textContent='Group not finished';
            }

            // ----- NUEVO: fila badges + descripci√≥n ---------
            const infoRow=document.createElement('div');
            infoRow.className='group-info-row';
            // badgesRow ya creado antes: lo usamos
            badgesRow.classList.add('badges-inline');
            infoRow.appendChild(badgesRow);
            ptsDesc.style.marginLeft='auto';
            infoRow.appendChild(ptsDesc);
            headerWrap.appendChild(infoRow);

            // Ajustar margen inferior del header
            headerWrap.style.marginBottom='20px';

            // Estructura final: solo las dos tablas
            tablesContainer.appendChild(twoWrap);

            groupCard.appendChild(tablesContainer);
            standingsContainer.appendChild(groupCard);

            // Comportamiento de colapsar/expandir
            headerTop.addEventListener('click',()=>{
              const collapsedNow = tablesContainer.style.display !== 'none'; // true => expanded currently
              if(collapsedNow){
                // will collapse
                tablesContainer.style.display='none';
                badgesRow.style.display='';
                arrowGrp.textContent='‚ñ∂';
                headerWrap.style.marginBottom='0';
              } else {
                // will expand
                tablesContainer.style.display='';
                badgesRow.style.display='none';
                arrowGrp.textContent='‚ñº';
                headerWrap.style.marginBottom='20px';
              }
            });

            // Determinar estado LIVE y completado del grupo
            const groupMatchesAll = Object.values(matchesById).filter(m=> m.phase==='group' && m.group===groupKey);
            const todayStr = new Date().toISOString().split('T')[0];
            const isLiveGroup = groupMatchesAll.some(m=> {
              if(m.dateTime.split('T')[0] !== todayStr) return false;
              const res=resultsById[m.matchId];
              const notPlayed = !(res && res.homeGoals!==null && res.awayGoals!==null);
              return notPlayed; // partido de hoy sin resultado
            });
            const isCompleteGroup = isGroupComplete(realGroupStandings[groupKey]);
            const insertStatusBadge=(imgEl)=>{ groupTitle.insertAdjacentElement('afterend', imgEl); };
            if(isLiveGroup){
              const liveImg=document.createElement('img');
              liveImg.src='live.svg';
              liveImg.alt='Live';
              liveImg.className='badge-icon live-icon';
              insertStatusBadge(liveImg);
            } else if(isCompleteGroup){
              const checkImg=document.createElement('img');
              checkImg.src='check.svg';
              checkImg.alt='Completed';
              checkImg.className='badge-icon';
              insertStatusBadge(checkImg);
            }

            // ----- Estado inicial colapsado/expandido (clasificaciones) -----
            // Guardamos preferencia del usuario en localStorage para cada grupo.
            const storageKey = `classifCollapsed_${groupKey}`;
            const storedState = localStorage.getItem(storageKey);
            const initiallyCollapsed = storedState === 'true'; // solo colapsado si usuario lo decidi√≥

            if (initiallyCollapsed) {
              tablesContainer.style.display = 'none';
              badgesRow.style.display = '';
              arrowGrp.textContent = '‚ñ∂';
              headerWrap.style.marginBottom = '0';
            } else {
              badgesRow.style.display = 'none';
            }

            // Actualizar almacenamiento al colapsar/expandir
            headerTop.addEventListener('click', () => {
              const willCollapse = tablesContainer.style.display !== 'none';
              localStorage.setItem(storageKey, willCollapse ? 'true' : 'false');
            });
        });
        predTab.style.display = 'block';
      } else {
        predTab.style.display = 'none';
      }

      // Calcular puntos por secci√≥n
      let groupStagePts=0, koStagePts=0;
      groupPreds.forEach(p=>{ groupStagePts+=calculateMatchPoints(p); });
      koPreds.forEach(p=>{ koStagePts+=calculateMatchPoints(p); });
      // Clasificaci√≥n puntos
      let classifPts=0;
      if(userStandings){
        Object.keys(userStandings).forEach(g=>{
          if(isGroupComplete(realGroupStandings[g])){
            classifPts+=calcGroupPoints(userStandings[g], realGroupStandings[g]);
          }
        });
      }
      // Actualizar spans con l√≥gica especial para KO todav√≠a no iniciado
      const setGroupTotal = (val)=>{
        const el=document.getElementById('groupPredTotal');
        if(el){ el.textContent=`${val} pts`; }
      };
      const setKOTotal = (val)=>{
        const el=document.getElementById('koPredTotal');
        if(!el) return;
        if(val===0){
          // Comprobar si hay alg√∫n partido KO con resultado registrado
          const anyKOPlayed = Object.values(matchesById).some(m=> m.phase!=='group' && resultsById[m.matchId] && resultsById[m.matchId].homeGoals!==null && resultsById[m.matchId].awayGoals!==null);
          el.textContent = anyKOPlayed ? '0 pts' : '-';
        } else {
          el.textContent = `${val} pts`;
        }
      };
      const setClassifTotal = (val)=>{
        const el=document.getElementById('classifTotal');
        if(el){ el.textContent=`${val} pts`; }
      };

      setGroupTotal(groupStagePts);
      setKOTotal(koStagePts);
      setClassifTotal(classifPts);
      // Actualizar iconos LIVE en los headers seg√∫n contenido renderizado
      refreshHeaderLiveIcons();

      /* ---------------- Leader Stats ---------------- */
      const statsEl=document.getElementById('leaderStats');
      if(statsEl){
        // Aciertos exactos y signo
        let exact=0, sign=0, played=0, totalPtsPlayed=0;
        userPreds.forEach(pred=>{
          const res=resultsById[pred.matchId];
          if(res && res.homeGoals!==null){
            played++;
            const pts=calculateMatchPoints(pred);
            totalPtsPlayed+=pts;
            if(pts===5) exact++; else if(pts===3) sign++;
          }
        });
        const exactPct = played? ((exact/played)*100).toFixed(1):'0';
        const signPct = played? ((sign/played)*100).toFixed(1):'0';
        const avgPts = played? (totalPtsPlayed/played).toFixed(2):'0';

        // Grupos puntos
        let perfect=0, semi=0, oneQual=0, groupsCompleted=0;
        Object.keys(realGroupStandings).forEach(g=>{
          if(isGroupComplete(realGroupStandings[g])){
            groupsCompleted++;
            const pts=calcGroupPoints((userStandings||{})[g], realGroupStandings[g]);
            if(pts===7) perfect++; else if(pts===5) semi++; else if(pts===2) oneQual++; 
          }
        });
        const grpPct=(val)=> groupsCompleted? ((val/groupsCompleted)*100).toFixed(1):'0';

        // Puntos m√°ximos posibles
        const currentTotal = leaderboard.find(e=>e.userId===userId)?.points || 0;
        const remainingMatches = userPreds.filter(p=>{
          const res=resultsById[p.matchId];
          return !(res && res.homeGoals!==null);
        }).length;
        const incompleteGroups = 8 - groupsCompleted;
        const maxPotential = currentTotal + remainingMatches*5 + incompleteGroups*7;

        const makeCard=(label,value)=>`<div class=\"stat-card\"><span class=\"stat-value\">${value}</span><span class=\"stat-label\">${label}</span></div>`;
        statsEl.innerHTML=`
          <div class=\"stat-set\">
            <div class=\"stat-set-title\">Matches Stats.</div>
            <div class=\"stat-group\">
              ${makeCard('Exact scores', `${exact} ‚Ä¢ ${exactPct}%`)}
              ${makeCard('Outcome hits', `${sign} ‚Ä¢ ${signPct}%`)}
              ${makeCard('pts / match', `${avgPts}`)}
            </div>
          </div>
          <div class=\"stat-set\">
            <div class=\"stat-set-title\">Groups Stats.</div>
            <div class=\"stat-group\">
              ${makeCard('Perfect', `${perfect} ‚Ä¢ ${grpPct(perfect)}%`)}
              ${makeCard('Semi-perfect', `${semi} ‚Ä¢ ${grpPct(semi)}%`)}
              ${makeCard('1 qualifier', `${oneQual} ‚Ä¢ ${grpPct(oneQual)}%`)}
            </div>
          </div>
        `;
      }
    }

    function renderPredTable(predArray, tbody, isKO){
        const todayStr = new Date().toISOString().split('T')[0];
        tbody.innerHTML='';
        // Sort predictions by date ascending
        predArray.sort((a, b) => new Date(matchesById[a.matchId]?.dateTime) - new Date(matchesById[b.matchId]?.dateTime));

        // Agrupamos por d√≠a (YYYY-MM-DD)
        const groups = {};
        predArray.forEach(p=>{
            const dKey = matchesById[p.matchId]?.dateTime.split('T')[0];
            if(!groups[dKey]) groups[dKey]=[];
            groups[dKey].push(p);
        });

        const dateKeys = Object.keys(groups).sort();

        // Determinar el primer d√≠a con al menos un partido sin resultado (d√≠a "LIVE")
        let ongoingDayKey = null;

        const isGroupStageComplete = !Object.values(matchesById).some(m=> m.phase==='group' && !(resultsById[m.matchId] && resultsById[m.matchId].homeGoals!==null && resultsById[m.matchId].awayGoals!==null));

        if(!isKO){
          // Fase de grupos: siempre aplicamos l√≥gica LIVE
          for(const dk of dateKeys){
            const incomplete = groups[dk].some(pred=>{
              const res = resultsById[pred.matchId];
              return !(res && res.homeGoals!==null && res.awayGoals!==null);
            });
            if(incomplete){ ongoingDayKey = dk; break; }
          }
        } else if(isGroupStageComplete){
          // Solo mostrar LIVE en KO si todos los grupos terminaron
          for(const dk of dateKeys){
            const incomplete = groups[dk].some(pred=>{
              const res = resultsById[pred.matchId];
              return !(res && res.homeGoals!==null && res.awayGoals!==null);
            });
            if(incomplete){ ongoingDayKey = dk; break; }
          }
        }

        // D√≠a inmediatamente anterior al LIVE (si existe)
        let prevDayKey = null;
        if(ongoingDayKey){
          const idx=dateKeys.indexOf(ongoingDayKey);
          if(idx>0) prevDayKey=dateKeys[idx-1];
        }

        // Funci√≥n para calcular puntos por predicci√≥n
        const calcPoints = (pred)=>{
            const res=resultsById[pred.matchId];
            if(res && res.homeGoals!==null){
                const diff=res.homeGoals-res.awayGoals;
                const predDiff=pred.predHome-pred.predAway;
                const matchInfo = matchesById[pred.matchId];
                
                // Para fase de knockout, verificar que los equipos predichos coincidan con los reales
                if(matchInfo && matchInfo.phase !== 'group'){
                    // Obtener equipos predichos
                    const resolveUserToken=(tok)=>{
                      if(teamIdToName[tok]) return teamIdToName[tok];
                      if(/^[12][A-H]$/i.test(tok)){
                        const pos=parseInt(tok[0],10);
                        const grp=tok[1].toUpperCase();
                        
                        // Primero intentar usar clasificaci√≥n real si est√° disponible
                        const realArr = realGroupStandings[grp];
                        const groupFinished = realArr && realArr.every(t => t.matchesPlayed === 3);
                        if(groupFinished && realArr[pos-1]){
                          return realArr[pos-1].teamName;
                        }
                        
                        // Si no hay clasificaci√≥n real o no est√° completa, usar la predicha
                        const arr=currentPredStandings[grp];
                        if(arr){
                          const found=arr.find(t=>t.position===pos);
                          if(found) return found.teamName;
                          if(arr[pos-1]) return arr[pos-1].teamName;
                        }
                      }
                      if(/^W\d+$/i.test(tok)){
                        const winnerId=getPredictedWinner(participantSelect.value, tok);
                        if(winnerId && teamIdToName[winnerId]) return teamIdToName[winnerId];
                      }
                      return tok;
                    };
                    
                    // Obtener equipos reales
                    const resolveTeamToken = (token) => {
                       if (teamIdToName[token]) return teamIdToName[token];
                       if (/^W\d+$/i.test(token)) {
                         const match = matchesById[token];
                         const res = resultsById[token];
                         if(match && res && res.homeGoals!==null && res.awayGoals!==null){
                            let winnerId=null;
                            if(res.homeGoals>res.awayGoals){ winnerId=match.homeTeam; }
                            else if(res.awayGoals>res.homeGoals){ winnerId=match.awayTeam; }
                            else {
                              // Empate en 90m - verificar E.T. y penalties
                              if(res.extraTime && res.extraTime.homeExtraTimeGoals!==null && res.extraTime.awayExtraTimeGoals!==null){
                                const totalHome = res.homeGoals + res.extraTime.homeExtraTimeGoals;
                                const totalAway = res.awayGoals + res.extraTime.awayExtraTimeGoals;
                                
                                if(totalHome > totalAway){ winnerId=match.homeTeam; }
                                else if(totalAway > totalHome){ winnerId=match.awayTeam; }
                                else {
                                  // Empate en E.T. - verificar penalties
                                  if(res.penalties && res.penalties.homePenaltyGoals!==null && res.penalties.awayPenaltyGoals!==null){
                                    if(res.penalties.homePenaltyGoals>res.penalties.awayPenaltyGoals){ winnerId=match.homeTeam; }
                                    else if(res.penalties.awayPenaltyGoals>res.penalties.homePenaltyGoals){ winnerId=match.awayTeam; }
                                  }
                                }
                              } else if(res.penalties && res.penalties.homePenaltyGoals!==null && res.penalties.awayPenaltyGoals!==null){
                                // No hay E.T. pero s√≠ penalties
                                if(res.penalties.homePenaltyGoals>res.penalties.awayPenaltyGoals){ winnerId=match.homeTeam; }
                                else if(res.penalties.awayPenaltyGoals>res.penalties.homePenaltyGoals){ winnerId=match.awayTeam; }
                              }
                            }
                            if(winnerId && teamIdToName[winnerId]) return teamIdToName[winnerId];
                         }
                       }
                       if (/^[12][A-H]$/i.test(tok)) {
                         const pos = parseInt(token[0], 10);
                         const group = token[1].toUpperCase();
                         const standingsArr = realGroupStandings[group];
                         const groupFinished = standingsArr && standingsArr.every(t => t.matchesPlayed === 3);
                         if (groupFinished && standingsArr[pos - 1]) {
                           return standingsArr[pos - 1].teamName;
                         }
                       }
                       return token;
                    };
                    
                    // Obtener placeholders originales del displayName
                    const parts = matchInfo.displayName.split(' vs ').map(s => s.trim());
                    let predHomeTok, predAwayTok;
                    if(parts.length === 2){
                      predHomeTok = parts[0];
                      predAwayTok = parts[1];
                    } else {
                      predHomeTok = matchInfo.homeTeam;
                      predAwayTok = matchInfo.awayTeam;
                    }
                    
                    const realTokHome = matchInfo.homeTeam;
                    const realTokAway = matchInfo.awayTeam;
                    
                    // Resolver nombres de equipos
                    const predHomeName = resolveUserToken(predHomeTok);
                    const predAwayName = resolveUserToken(predAwayTok);
                    const realHomeName = resolveTeamToken(realTokHome);
                    const realAwayName = resolveTeamToken(realTokAway);
                    
                    // Verificar que los equipos coincidan
                    if(predHomeName !== realHomeName || predAwayName !== realAwayName){
                        return 0; // No hay puntos si los equipos no coinciden
                    }
                }
                
                // Si llegamos aqu√≠, los equipos coinciden (o es fase de grupos)
                if(pred.predHome===res.homeGoals && pred.predAway===res.awayGoals) return 5;
                
                // Para fase de grupos: comparar solo 90m
                if(matchInfo && matchInfo.phase === 'group'){
                    if((diff===0 && predDiff===0)||(diff>0 && predDiff>0)||(diff<0 && predDiff<0)) return 3;
                } else {
                    // Para fase de knockout: comparar ganador final (incluyendo E.T. y penalties)
                    // Los equipos ya han sido verificados arriba
                    // Determinar ganador predicho
                    let predWinner = null;
                    if(pred.predHome > pred.predAway) predWinner = 'home';
                    else if(pred.predAway > pred.predHome) predWinner = 'away';
                    else {
                        // Empate en predicci√≥n - usar penalties si existen
                        if(pred.predPenalties){
                            if(pred.predPenalties.home > pred.predPenalties.away) predWinner = 'home';
                            else if(pred.predPenalties.away > pred.predPenalties.home) predWinner = 'away';
                        }
                    }
                    
                    // Determinar ganador real
                    let realWinner = null;
                    if(res.homeGoals > res.awayGoals) realWinner = 'home';
                    else if(res.awayGoals > res.homeGoals) realWinner = 'away';
                    else {
                        // Empate en 90m - verificar E.T.
                        if(res.extraTime && res.extraTime.homeExtraTimeGoals !== null && res.extraTime.awayExtraTimeGoals !== null){
                            const totalHome = res.homeGoals + res.extraTime.homeExtraTimeGoals;
                            const totalAway = res.awayGoals + res.extraTime.awayExtraTimeGoals;
                            
                            if(totalHome > totalAway) realWinner = 'home';
                            else if(totalAway > totalHome) realWinner = 'away';
                            else {
                                // Empate en E.T. - verificar penalties
                                if(res.penalties && res.penalties.homePenaltyGoals !== null && res.penalties.awayPenaltyGoals !== null){
                                    if(res.penalties.homePenaltyGoals > res.penalties.awayPenaltyGoals) realWinner = 'home';
                                    else if(res.penalties.awayPenaltyGoals > res.penalties.homePenaltyGoals) realWinner = 'away';
                                }
                            }
                        } else if(res.penalties && res.penalties.homePenaltyGoals !== null && res.penalties.awayPenaltyGoals !== null){
                            // No hay E.T. pero s√≠ penalties
                            if(res.penalties.homePenaltyGoals > res.penalties.awayPenaltyGoals) realWinner = 'home';
                            else if(res.penalties.awayPenaltyGoals > res.penalties.homePenaltyGoals) realWinner = 'away';
                        }
                    }
                    
                    // Si ambos ganadores est√°n definidos y coinciden, dar 3 puntos
                    if(predWinner && realWinner && predWinner === realWinner) return 3;
                }
            }
            return 0;
        };

        const dayPointsMap = {};
        dateKeys.forEach(k=>{
            dayPointsMap[k]=groups[k].reduce((sum,p)=> sum+calculateMatchPoints(p),0);
        });

        // NUEVO: determinar d√≠as a mostrar abiertos (√∫ltimo d√≠a completo + pr√≥ximos 24h)
        const upcomingDayKeys=[];
        const nowMs=Date.now();
        const liveWindow=nowMs+24*60*60*1000;
        const considerLive = (!isKO) || isGroupStageComplete; // En KO solo aplica cuando ya termin√≥ la fase de grupos
        if(considerLive){
          dateKeys.forEach(dk=>{
            const hasUpcoming = groups[dk].some(p=>{
              const matchInfo=matchesById[p.matchId];
              const t=new Date(matchInfo.dateTime).getTime();
              return t>=nowMs && t<=liveWindow;
            });
            if(hasUpcoming){ upcomingDayKeys.push(dk); }
          });
        }

        let lastCompleteDayKey=null;
        for(let i=dateKeys.length-1;i>=0;i--){
          const dk=dateKeys[i];
          const allPlayed=groups[dk].every(p=>{
            const res=resultsById[p.matchId];
            return res && res.homeGoals!==null && res.awayGoals!==null;
          });
          if(allPlayed){ lastCompleteDayKey=dk; break; }
        }

        dateKeys.forEach(dateKey=>{
            const headerTr=document.createElement('tr');
            headerTr.className='day-header';
            const colSpan=isKO?7:6;
            const formattedDate=formatDateEnglish(new Date(dateKey));
            const isInitiallyOpen = FORCE_OPEN_DAYS.includes(dateKey) || upcomingDayKeys.includes(dateKey) || dateKey===lastCompleteDayKey;
            const arrow=isInitiallyOpen?'‚ñº':'‚ñ∂';
            const pts=dayPointsMap[dateKey];
            // Determinar si al menos un partido de ese d√≠a ya tiene resultado
            const anyPlayed = groups[dateKey].some(pred=>{
                const res=resultsById[pred.matchId];
                return res && res.homeGoals!==null && res.awayGoals!==null;
            });
            const ptsDisplay = anyPlayed ? `${pts} pts` : '-';
            const matchesToday=groups[dateKey];
            const allPlayedDay=matchesToday.every(pred=>{
                const res=resultsById[pred.matchId];
                return res && res.homeGoals!==null && res.awayGoals!==null;
            });
            let liveFlag=false;
            // Regla principal: si hoy y a√∫n quedan partidos sin jugar -> LIVE
            if(dateKey===todayStr){
               liveFlag = !allPlayedDay; // solo si NO est√° completo
            }
            // Si todav√≠a no es LIVE por la regla anterior, comprobamos si hay partidos futuros en <24h sin jugar (l√≥gica anterior)
            if(!liveFlag){
              for(const pred of matchesToday){
                  const info=matchesById[pred.matchId];
                  const t=new Date(info.dateTime).getTime();
                  const res=resultsById[pred.matchId];
                  const played=res && res.homeGoals!==null && res.awayGoals!==null;
                  if(!played && t>=nowMs && t<=liveWindow){ liveFlag=true; break; }
              }
            }

            // Escudos de equipos confirmados (solo KO)
            let dayBadgesHtml='';
            if(isKO){
              const badgeArr=[];
              const pushBadge=(tok)=>{
                let idTok=null;
                if(teamIdToBadge[tok]){ 
                  idTok=tok; 
                }
                else if(/^[12][A-H]$/i.test(tok)){
                  const pos = parseInt(tok[0], 10);
                  const grp = tok[1].toUpperCase();
                  if (realGroupStandings[grp] && isGroupComplete(realGroupStandings[grp])) {
                    const team = realGroupStandings[grp].find(t => t.position === pos);
                    idTok = team ? team.teamId : null;
                  }
                }
                else if(/^W\d+$/i.test(tok)){
                   const r=resultsById[tok];
                   if(r && r.homeGoals!==null){
                      const m=matchesById[tok];
                      const winnerSide = getRealWinner(r);
                      if(winnerSide){
                         const winnerToken = winnerSide === 'home' ? m.homeTeam : m.awayTeam;
                         // Resoluci√≥n recursiva usando la misma funci√≥n
                         const recursiveSrc = getRealTeamBadge ? getRealTeamBadge(winnerToken) : 'badges/unknownTeam.png';
                         badgeArr.push(`<img src="${recursiveSrc}" class="team-badge" alt="team"/>`);
                         return; // Salir temprano para evitar duplicar
                      }
                   }
                }
                let src='badges/unknownTeam.png';
                if(idTok && teamIdToBadge[idTok]) src=teamIdToBadge[idTok];
                badgeArr.push(`<img src="${src}" class="team-badge" alt="team"/>`);
              };
              matchesToday.forEach(pred=>{
                const mi=matchesById[pred.matchId];
                pushBadge(mi.homeTeam);
                pushBadge(mi.awayTeam);
              });
              dayBadgesHtml=badgeArr.join('');
            }

            const liveBadge=liveFlag?'<img src="live.svg" class="badge-icon live-icon" alt="Live"/>':'';
            const completedBadge=(allPlayedDay && new Date(dateKey).getTime()<nowMs)?'<img src="check.svg" class="badge-icon" alt="Completed"/>':'';
            if(isKO){
              headerTr.dataset.dateKey=dateKey;
              headerTr.innerHTML=`<td colspan="${colSpan}"><div class="day-header-content"><span class="arrow">${arrow}</span><span class="date-text">${formattedDate}</span>${liveBadge}${completedBadge}<span class="points-badge">${ptsDisplay}</span></div><div class="phase-badges-row">${dayBadgesHtml}</div></td>`;
              // Ocultar badges si el d√≠a estar√° inicialmente expandido
              if(isInitiallyOpen){
                  const rowBadges=headerTr.querySelector('.phase-badges-row');
                  if(rowBadges) rowBadges.style.display='none';
              } else {
                  const rowBadges=headerTr.querySelector('.phase-badges-row');
                  if(rowBadges) rowBadges.style.display='flex';
              }
            } else {
              headerTr.innerHTML=`<td colspan="${colSpan}"><div class="day-header-content"><span class="arrow">${arrow}</span><span class="date-text">${formattedDate}</span>${liveBadge}${completedBadge}<span class="points-badge">${ptsDisplay}</span></div></td>`;
            }
            tbody.appendChild(headerTr);

            // Sub‚Äêheader con nombres de columnas para este d√≠a
            const subHeaderTr=document.createElement('tr');
            subHeaderTr.className='sub-header';
            const subHeaders=isKO?
              ['Time','Round','Pred.','Real','Pred.','Real','Pts']:
              ['Time','Round','Match','Pred.','Real','Pts'];

            subHeaderTr.innerHTML=subHeaders.map((h,idx)=>{
                if(idx===subHeaders.length-1){
                    const inner = anyPlayed ? `${ptsDisplay}` : '-';
                    return `<td class=\"pts-header-cell\"><span class=\"day-total points-badge\" style=\"display:none\">${inner}</span><span class=\"pts-text\">${anyPlayed?'pts':''}</span></td>`;
                }
                return `<td>${h}</td>`;
            }).join('');
            tbody.appendChild(subHeaderTr);

            // rows for this date
            groups[dateKey].forEach(pred=>{
                const matchInfo=matchesById[pred.matchId];
                const date=new Date(matchInfo.dateTime);
                const timePart=date.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',hour12:false});
                const matchDate=`${timePart}`;

                let roundText='-';
                switch(matchInfo.phase){case 'group':roundText=`Group ${matchInfo.group}`;break;case 'ro16':roundText='Round of 16';break;case 'qf':roundText='Quarter-Final';break;case 'sf':roundText='Semi-Final';break;case 'final':roundText='Final';break;default:roundText=matchInfo.phase;}
                // Construir versi√≥n m√≥vil/desktop
                let roundShort=''; let roundExtra='';
                if(matchInfo.phase==='group'){
                  roundShort='Grp.';
                  roundExtra=matchInfo.group; // letra del grupo
                } else {
                  switch(matchInfo.phase){
                    case 'ro16': roundShort='R16'; break;
                    case 'qf': roundShort='QF'; break;
                    case 'sf': roundShort='SF'; break;
                    case 'final': roundShort='F'; break;
                    default: roundShort=matchInfo.phase;
                  }
                  if(isKO){ roundExtra=`(${matchInfo.matchId})`; }
                }

                let roundMobile='';
                if(matchInfo.phase==='group'){
                  roundMobile=`${roundShort}<br/>${roundExtra}`; // Grp. + letra
                } else {
                  roundMobile=`${roundShort}${roundExtra?`<br/>${roundExtra}`:''}`;
                }

                // Construir contenido de escritorio: ronda + salto de l√≠nea + matchId si KO
                let roundDesktopContent=roundText;
                if(matchInfo.phase!=='group' && isKO){
                   roundDesktopContent=`${roundText}<br/><span class=\"round-id\">(${matchInfo.matchId})</span>`;
                 }
                const roundHtml=`<span class=\"round-desktop\">${roundDesktopContent}</span><span class=\"round-mobile\">${roundMobile}</span>`;

                // Mostrar penaltis si hay empate y se han pronosticado
                let penHome='', penAway='';
                if(pred.predHome===pred.predAway && pred.predPenalties){
                   penHome=` (${pred.predPenalties.home})`;
                   penAway=` (${pred.predPenalties.away})`;
                }
                // Construir predicci√≥n para KO con 90m y Pen.
                let predScoreHtml = '';
                if (isKO) {
                    // 90m siempre
                    predScoreHtml = `<div class=\"score-group\">
                        <div class=\"score-group-label\">90m.</div>
                        <div class=\"score-group-main\">
                            <span class=\"home-score\">${pred.predHome}</span>
                            <span class=\"away-score\">${pred.predAway}</span>
                        </div>
                    </div>`;
                    // Penalties si hay predicci√≥n de empate y penaltis
                    if (pred.predHome === pred.predAway && pred.predPenalties && pred.predPenalties.home !== null && pred.predPenalties.away !== null) {
                        predScoreHtml += `<div class=\"penalties-group\">
                            <div class=\"score-group-label\">Pen.</div>
                            <div class=\"score-group-main\">
                                <span class=\"home-score\">${pred.predPenalties.home}</span>
                                <span class=\"away-score\">${pred.predPenalties.away}</span>
                            </div>
                        </div>`;
                    }
                    predScoreHtml = `<div class=\"result-container\">${predScoreHtml}</div>`;
                } else {
                    // Fase de grupos: solo mostrar goles de 90m verticalmente sin etiqueta
                    predScoreHtml = `<div class=\"score-group-main\">
                        <span class=\"home-score\">${pred.predHome}</span>
                        <span class=\"away-score\">${pred.predAway}</span>
                    </div>`;
                }
                
                // Construir resultado real con tiempo extra y penalties
                let realScoreHtml = '';
                if (resultsById[pred.matchId] && resultsById[pred.matchId].homeGoals !== null) {
                    const result = resultsById[pred.matchId];
                    const homeGoals = result.homeGoals;
                    const awayGoals = result.awayGoals;
                    
                    // Para fase de grupos: solo mostrar goles de 90m verticalmente sin etiqueta
                    if (matchInfo.phase === 'group') {
                        realScoreHtml = `<div class="score-group-main">
                            <span class="home-score">${homeGoals}</span>
                            <span class="away-score">${awayGoals}</span>
                        </div>`;
                    } else {
                        // Para fase de KO: mostrar grupos completos con etiquetas
                        // Grupo 90m (siempre visible)
                        let scoreHtml = `<div class="score-group">
                            <div class="score-group-label">90m.</div>
                            <div class="score-group-main">
                                <span class="home-score">${homeGoals}</span>
                                <span class="away-score">${awayGoals}</span>
                            </div>
                        </div>`;
                        
                        // Grupo E.T. (solo si hay empate en 90m y hay tiempo extra)
                        let extraTimeHtml = '';
                        if (homeGoals === awayGoals && result.extraTime && result.extraTime.homeExtraTimeGoals !== null && result.extraTime.awayExtraTimeGoals !== null) {
                            const totalHomeGoals = homeGoals + result.extraTime.homeExtraTimeGoals;
                            const totalAwayGoals = awayGoals + result.extraTime.awayExtraTimeGoals;
                            extraTimeHtml = `<div class="extra-time-group">
                                <div class="score-group-label">120M.</div>
                                <div class="score-group-main">
                                    <span class="home-score">${totalHomeGoals}</span>
                                    <span class="away-score">${totalAwayGoals}</span>
                                </div>
                            </div>`;
                        }
                        
                        // Grupo Pen. (solo si hay empate en E.T. y hay penalties)
                        let penaltiesHtml = '';
                        if (result.extraTime && result.extraTime.homeExtraTimeGoals !== null && result.extraTime.awayExtraTimeGoals !== null) {
                            const totalHomeGoals = homeGoals + result.extraTime.homeExtraTimeGoals;
                            const totalAwayGoals = awayGoals + result.extraTime.awayExtraTimeGoals;
                            if (totalHomeGoals === totalAwayGoals && result.penalties && result.penalties.homePenaltyGoals !== null && result.penalties.awayPenaltyGoals !== null) {
                                penaltiesHtml = `<div class="penalties-group">
                                    <div class="score-group-label">Pen.</div>
                                    <div class="score-group-main">
                                        <span class="home-score">${result.penalties.homePenaltyGoals}</span>
                                        <span class="away-score">${result.penalties.awayPenaltyGoals}</span>
                                    </div>
                                </div>`;
                            }
                        }
                        
                        realScoreHtml = `<div class="result-container">${scoreHtml}${extraTimeHtml}${penaltiesHtml}</div>`;
                    }
                } else {
                    realScoreHtml = `<span class="home-score">-</span><span class="score-sep">-</span><span class="away-score">-</span>`;
                }
                let points=0;
                const played = (resultsById[pred.matchId] && resultsById[pred.matchId].homeGoals!==null);
                if(played){
                    points = calculateMatchPoints(pred); // Usa funci√≥n central con verificaci√≥n de equipos
                }

                // Determinar texto y clase para badge de puntos
                let ptsClass='none';
                let ptsText='-';
                if(played){
                  ptsText=points.toString();
                  ptsClass = points>0? 'earned' : 'zero';
                }

                let rowHtml='';
                if(isKO){
                    const resolveUserToken=(tok)=>{
                      const id = resolvePredictedTeamId(participantSelect.value, tok);
                      return teamIdToName[id] || tok;
                    };
                    const resolveRealTokenName=(tok)=>{
                      const id = resolveRealTeamId(tok);
                      return teamIdToName[id] || tok;
                    };

                    const realTokHome = matchInfo.homeTeam;
                    const realTokAway = matchInfo.awayTeam;

                    const buildSpan=(tok, resolvedName, isReal=false)=>{
                      let resolvedId = isReal ? resolveRealTeamId(tok) : resolvePredictedTeamId(participantSelect.value, tok);
                      let src = (resolvedId && teamIdToBadge[resolvedId]) ? teamIdToBadge[resolvedId] : 'badges/unknownTeam.png';

                      const badge=src?`<img src="${src}" class="team-badge" alt="${resolvedName} badge"/>`:'';
                      return `${badge}<span class="team-id">${tok}</span><span class="team-name-full">${resolvedName}</span>`;
                    };

                    // Tokens basados en el displayName (mantienen placeholders 1A, W49, ...)
                    const displayParts = matchInfo.displayName.split(' vs ').map(s => s.trim());
                    const predTokHome = displayParts.length === 2 ? displayParts[0] : matchInfo.homeTeam;
                    const predTokAway = displayParts.length === 2 ? displayParts[1] : matchInfo.awayTeam;

                    const predictedSpanHome = buildSpan(predTokHome, resolveUserToken(predTokHome), false);
                    const predictedSpanAway = buildSpan(predTokAway, resolveUserToken(predTokAway), false);
                    const predictedHtml = `<span class=\"home-team\">${predictedSpanHome}</span><span class=\"vs-sep\">vs</span><span class=\"away-team\">${predictedSpanAway}</span>`;

                    const realSpanHome = buildSpan(realTokHome, resolveRealTokenName(realTokHome), true);
                    const realSpanAway = buildSpan(realTokAway, resolveRealTokenName(realTokAway), true);
                    const realHtml = `<span class=\"home-team\">${realSpanHome}</span><span class=\"vs-sep\">vs</span><span class=\"away-team\">${realSpanAway}</span>`;
                    rowHtml=`<td class=\"time-cell\">${matchDate}</td><td class=\"round-cell\">${roundHtml}</td><td class=\"match-cell\">${predictedHtml}</td><td class=\"match-cell\">${realHtml}</td><td class=\"score-cell prediction\">${predScoreHtml}</td><td class=\"score-cell result\">${realScoreHtml}</td><td class=\"points-cell\"><span class=\"points-badge ${ptsClass}\">${ptsText}</span></td>`;
                } else {
                    // Fase de grupos
                    const homeId = matchInfo.homeTeam;
                    const awayId = matchInfo.awayTeam;
                    const homeBadge = teamIdToBadge[homeId] ? `<img src="${teamIdToBadge[homeId]}" class="team-badge" alt="${teamIdToName[homeId] || ''} badge"/>` : '';
                    const awayBadge = teamIdToBadge[awayId] ? `<img src="${teamIdToBadge[awayId]}" class="team-badge" alt="${teamIdToName[awayId] || ''} badge"/>` : '';
                    const homeName = teamIdToName[homeId] || matchInfo.displayName.split(' vs ')[0];
                    const awayName = teamIdToName[awayId] || matchInfo.displayName.split(' vs ')[1];
                    const matchCol = `<span class=\"home-team\">${homeBadge}<span class=\"team-id\">${homeId}</span><span class=\"team-name-full\">${homeName}</span></span><span class=\"vs-sep\">vs</span><span class=\"away-team\">${awayBadge}<span class=\"team-id\">${awayId}</span><span class=\"team-name-full\">${awayName}</span></span>`;
                    rowHtml=`<td class=\"time-cell\">${matchDate}</td><td class=\"round-cell\">${roundHtml}</td><td class=\"match-cell\">${matchCol}</td><td class=\"score-cell prediction\">${predScoreHtml}</td><td class=\"score-cell result\">${realScoreHtml}</td><td class=\"points-cell\"><span class=\"points-badge ${ptsClass}\">${ptsText}</span></td>`;
                }
                const tr=document.createElement('tr');
                tr.className=`match-row row-${dateKey}`;
                tr.innerHTML=rowHtml;
                tbody.appendChild(tr);
            });

            // collapsible behaviour
            const toggleRows=()=>{
                let next=headerTr.nextElementSibling;
                while(next && !next.classList.contains('day-header')){
                    next.style.display = (next.style.display==='none')?'':'none';
                    next=next.nextElementSibling;
                }
            };
            headerTr.addEventListener('click',()=>{
                toggleRows();
                const arrowSpan=headerTr.querySelector('.arrow');
                if(arrowSpan){
                    arrowSpan.textContent = (arrowSpan.textContent==='‚ñº')?'‚ñ∂':'‚ñº';
                }
                const badgesRowEl=headerTr.querySelector('.phase-badges-row');
                if(badgesRowEl){
                   const expanded = arrowSpan.textContent==='‚ñº';
                   badgesRowEl.style.display = expanded? 'none' : 'flex';
                }
                const badgeHeader=headerTr.querySelector('.points-badge');
                const badgeSub=subHeaderTr.querySelector('.day-total');
                const ptsText=subHeaderTr.querySelector('.pts-text');
                const isExpanded = arrowSpan.textContent==='‚ñº';
                if(isExpanded){
                    badgeHeader.style.visibility='hidden';
                    badgeSub.style.display='inline-block';
                    if(ptsText) ptsText.style.display='none';
                } else {
                    badgeHeader.style.visibility='visible';
                    badgeSub.style.display='none';
                    if(ptsText) ptsText.style.display='inline';
                }
            });

            // Inicialmente colapsamos si no debe estar abierto
            if(!isInitiallyOpen){
                toggleRows();
                const arrowSpan=headerTr.querySelector('.arrow');
                if(arrowSpan){ arrowSpan.textContent='‚ñ∂'; }
            } else {
                // Mostrar badge en subheader, ocultar en header
                const badgeHeader=headerTr.querySelector('.points-badge');
                const badgeSub=subHeaderTr.querySelector('.day-total');
                const ptsText=subHeaderTr.querySelector('.pts-text');
                badgeHeader.style.visibility='hidden';
                badgeSub.style.display='inline-block';
                if(ptsText) ptsText.style.display='none';
            }
        });
    }

    function resolveTeamToken(token) {
       if (teamIdToName[token]) return teamIdToName[token];
       if (/^W\d+$/i.test(token)) {
         const match = matchesById[token];
         const res = resultsById[token];
         if(match && res && res.homeGoals!==null && res.awayGoals!==null){
            let winnerId=null;
            if(res.homeGoals>res.awayGoals){ winnerId=match.homeTeam; }
            else if(res.awayGoals>res.homeGoals){ winnerId=match.awayTeam; }
            else {
              // Empate en 90m - verificar E.T. y penalties
              if(res.extraTime && res.extraTime.homeExtraTimeGoals!==null && res.extraTime.awayExtraTimeGoals!==null){
                const totalHome = res.homeGoals + res.extraTime.homeExtraTimeGoals;
                const totalAway = res.awayGoals + res.extraTime.awayExtraTimeGoals;
                
                if(totalHome > totalAway){ winnerId=match.homeTeam; }
                else if(totalAway > totalHome){ winnerId=match.awayTeam; }
                else {
                  // Empate en E.T. - verificar penalties
                  if(res.penalties && res.penalties.homePenaltyGoals!==null && res.penalties.awayPenaltyGoals!==null){
                    if(res.penalties.homePenaltyGoals>res.penalties.awayPenaltyGoals){ winnerId=match.homeTeam; }
                    else if(res.penalties.awayPenaltyGoals>res.penalties.homePenaltyGoals){ winnerId=match.awayTeam; }
                  }
                }
              } else if(res.penalties && res.penalties.homePenaltyGoals!==null && res.penalties.awayPenaltyGoals!==null){
                // No hay E.T. pero s√≠ penalties
                if(res.penalties.homePenaltyGoals>res.penalties.awayPenaltyGoals){ winnerId=match.homeTeam; }
                else if(res.penalties.awayPenaltyGoals>res.penalties.homePenaltyGoals){ winnerId=match.awayTeam; }
              }
            }
            if(winnerId && teamIdToName[winnerId]) return teamIdToName[winnerId];
         }
       }
       if (/^[12][A-H]$/i.test(token)) {
         const pos = parseInt(token[0], 10);
         const group = token[1].toUpperCase();
         const standingsArr = realGroupStandings[group];
         const groupFinished = standingsArr && standingsArr.every(t => t.matchesPlayed === 3);
         if (groupFinished && standingsArr[pos - 1]) {
           return standingsArr[pos - 1].teamName;
         }
       }
       return token; // Mantener placeholder (Wxx, 1A, etc.)
    }

    function getRealKOName(match) {
      // NUEVO: resolvemos a partir de displayName para mantener placeholders cuando proceda
      const parts = match.displayName.split(' vs ').map(s => s.trim());
      if(parts.length === 2){
        const home = resolveTeamToken(parts[0]);
        const away = resolveTeamToken(parts[1]);
        return `${home} vs ${away}`;
      }
      const home = resolveTeamToken(match.homeTeam);
      const away = resolveTeamToken(match.awayTeam);
      return `${home} vs ${away}`;
    }

    function showTab(tab){
        if(tab==='pred'){
            predTab.style.display='block';
            clasifTab.style.display='none';
            standingsSection.style.display='block';
            predControls.style.display='block';
            btnPred.classList.add('tab-active');
            btnClasif.classList.remove('tab-active');
            if(dataLoaded){
              displayParticipant(participantSelect.value);
            } else {
              pendingParticipant=participantSelect.value;
            }
            predTitle.textContent='';
        } else {
            predTab.style.display='none';
            clasifTab.style.display='block';
            standingsSection.style.display='none';
            predControls.style.display='none';
            btnClasif.classList.add('tab-active');
            btnPred.classList.remove('tab-active');
            predTitle.textContent='';
        }
    }

    // Los listeners de tabs ahora se configuran en setupStatePersistence()

    // Funciones para manejar persistencia del estado de la aplicaci√≥n
    function restoreApplicationState() {
        // Restaurar participante seleccionado primero
        const savedParticipant = localStorage.getItem('lastParticipant') || '';
        let participantRestored = false;
        
        if(savedParticipant && participantSelect.querySelector(`option[value="${savedParticipant}"]`)){
            participantSelect.value = savedParticipant;
            participantRestored = true;
            console.log('Estado restaurado - Participante:', savedParticipant);
        }
        
        // Restaurar pesta√±a activa
        const savedTab = localStorage.getItem('lastTab') || 'clasif';
        
        // L√≥gica de restauraci√≥n de tabs:
        // 1. Respetar siempre el tab guardado
        // 2. Si es 'pred' pero no hay participante ‚Üí ir a Leaderboard
        if(savedTab === 'pred' && !participantRestored) {
            // Si se intentaba mostrar Predictions pero no hay participante, ir a Leaderboard
            showTab('clasif');
            console.log('Estado restaurado - Tab: Leaderboard (no hay participante seleccionado)');
        } else {
            showTab(savedTab);
            console.log('Estado restaurado - Tab:', savedTab);
        }

        // Restaurar vista de grupo
        const savedView = localStorage.getItem('groupPredView') || 'date';
        console.log('Estado restaurado - Vista de grupo:', savedView);
    }

    function setupStatePersistence() {
        // Guardar cambios de participante
        participantSelect.addEventListener('change', () => {
            const selectedValue = participantSelect.value;
            if(selectedValue) {
                localStorage.setItem('lastParticipant', selectedValue);
                console.log('Estado guardado - Participante:', selectedValue);
                
                // Solo cambiar a Predictions si no estamos ya en Leaderboard
                if(!btnClasif.classList.contains('tab-active')) {
                    localStorage.setItem('lastTab', 'pred');
                    showTab('pred');
                } else {
                    // Si estamos en Leaderboard, mantenernos ah√≠ pero refrescar contenido si es necesario
                    console.log('Manteniendo tab Leaderboard activo');
                }
            } else {
                localStorage.removeItem('lastParticipant');
                localStorage.setItem('lastTab', 'clasif');
                console.log('Estado guardado - Participante eliminado');
                showTab('clasif');
            }
        });

        // Configurar listeners de tabs con logging
        btnPred.addEventListener('click', () => {
            localStorage.setItem('lastTab','pred');
            console.log('Estado guardado - Tab: Predictions');
            showTab('pred');
        });
        
        btnClasif.addEventListener('click', () => {
            localStorage.setItem('lastTab','clasif'); 
            console.log('Estado guardado - Tab: Leaderboard');
            showTab('clasif');
        });
    }

    function renderLeaderboard(){
        const tbody=document.querySelector('#leaderboardTable tbody');
        tbody.innerHTML='';

        // Determinar d√≠a ongoing y el inmediatamente anterior con todos los partidos finalizados
        const allDateMap={};
        Object.values(matchesById).forEach(m=>{
          const dKey=m.dateTime.split('T')[0];
          if(!allDateMap[dKey]) allDateMap[dKey]=[];
          allDateMap[dKey].push(m);
        });
        const allDateKeys=Object.keys(allDateMap).sort();
        let ongoingKey=null;
        for(const dk of allDateKeys){
          const unfinished=allDateMap[dk].some(m=>{
            const res=resultsById[m.matchId];
            return !(res && res.homeGoals!==null && res.awayGoals!==null);
          });
          if(unfinished){ ongoingKey=dk; break; }
        }
        const prevDayKey=allDateKeys[allDateKeys.indexOf(ongoingKey)-1] || null;

        // Actualizar cabecera con fecha
        const prevHeader=document.getElementById('prevDayHeader');
        if(prevHeader){
          if(prevDayKey){
            const dateObj=new Date(prevDayKey);
            const dateStr=formatDateEnglish(dateObj);
            prevHeader.textContent=`PREV. DAY`;
          } else {
            prevHeader.textContent='Points';
          }
        }

        // Calcular puntos obtenidos por usuario en prevDayKey
        const pointsYesterday={};
        if(prevDayKey){
          const calcPts=(pred)=>{
            const res=resultsById[pred.matchId];
            if(res && res.homeGoals!==null){
              const diff=res.homeGoals-res.awayGoals;
              const predDiff=pred.predHome-pred.predAway;
              if(pred.predHome===res.homeGoals && pred.predAway===res.awayGoals) return 5;
              if((diff===0 && predDiff===0)||(diff>0 && predDiff>0)||(diff<0 && predDiff<0)) return 3;
            }
            return 0;
          };
          predictions.forEach(pred=>{
            const match=matchesById[pred.matchId];
            if(match && match.dateTime.split('T')[0]===prevDayKey){
              pointsYesterday[pred.userId]=(pointsYesterday[pred.userId]||0)+calcPts(pred);
            }
          });
          // A√±adir puntos de grupos finalizados ese d√≠a
          Object.keys(realGroupStandings).forEach(g=>{
            const groupMatches=Object.values(matchesById).filter(m=>m.phase==='group' && m.group===g);
            const lastDate=groupMatches.reduce((max,m)=> m.dateTime>max?m.dateTime:max,'');
            if(lastDate.split('T')[0]===prevDayKey){
              participants.forEach(p=>{
                const uid=p.userId;
                const userGs=groupStandings[uid];
                if(userGs && userGs[g]){
                  const pts=calcGroupPoints(userGs[g], realGroupStandings[g]);
                  pointsYesterday[uid]=(pointsYesterday[uid]||0)+pts;
                }
              });
            }
          });
        }

        // Construir ranking del d√≠a anterior
        const prevTotals=leaderboard.map(e=>({userId:e.userId, pts:e.points-(pointsYesterday[e.userId]||0)}));
        prevTotals.sort((a,b)=> b.pts - a.pts);
        const prevRankMap={};
        let prevRankNum=1, lastPrevPts=null;
        prevTotals.forEach((item,idx)=>{
          if(idx>0 && item.pts!==lastPrevPts){ prevRankNum=idx+1; }
          prevRankMap[item.userId]=prevRankNum;
          lastPrevPts=item.pts;
        });

        // ---------- C√ÅLCULO HIST√ìRICO PARA PROGRESS (antes de crear filas) ----------
        const rankHistoryByUser={};
        const cumulativePoints={};
        participants.forEach(p=>{ cumulativePoints[p.userId]=0; rankHistoryByUser[p.userId]=[]; });

        const progressDates = ongoingKey ? allDateKeys.filter(dk=> dk<ongoingKey) : allDateKeys;

        progressDates.forEach(dk=>{
          predictions.forEach(pred=>{
            const match=matchesById[pred.matchId];
            if(match && match.dateTime.split('T')[0]===dk){
              const pts=calculateMatchPoints(pred);
              if(pts>0){ cumulativePoints[pred.userId]=(cumulativePoints[pred.userId]||0)+pts; }
            }
          });
          // puntos group clasif
          Object.keys(realGroupStandings).forEach(g=>{
            const real=realGroupStandings[g];
            if(!isGroupComplete(real)) return;
            const groupMatches=Object.values(matchesById).filter(m=> m.phase==='group' && m.group===g);
            const lastDate=groupMatches.reduce((max,m)=> m.dateTime>max?m.dateTime:max,'');
            if(lastDate.split('T')[0]!==dk) return;
            participants.forEach(p=>{
              const uid=p.userId;
              const userGs=groupStandings[uid];
              if(userGs && userGs[g]){
                const pts=calcGroupPoints(userGs[g], real);
                cumulativePoints[uid]=(cumulativePoints[uid]||0)+pts;
              }
            });
          });
          // ranking del d√≠a
          const sorted=Object.entries(cumulativePoints).sort((a,b)=> b[1]-a[1]);
          let rank=1, lastPts=null;
          sorted.forEach(([uid,pts],idx)=>{
            if(idx>0 && pts!==lastPts){ rank=idx+1; }
            rankHistoryByUser[uid].push(rank);
            lastPts=pts;
          });
        });

        const buildSparkline=(arr,maxRank)=>{
          if(!arr || arr.length===0) return '';
          const width=60, height=24;
          if(arr.length===1){
            const y=(arr[0]-1)/(maxRank-1)*height;
            return `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" preserveAspectRatio="none"><circle cx="${width}" cy="${y}" r="2" fill="#0969da" /></svg>`;
          }
          const step=width/(arr.length-1);
          const points=arr.map((r,i)=>{
            const x=i*step;
            const y=(r-1)/(maxRank-1)*height;
            return `${x},${y}`;
          }).join(' ');
          return `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" preserveAspectRatio="none"><polyline fill="none" stroke="#0969da" stroke-width="2" points="${points}" /></svg>`;
        };

        leaderboard.forEach((entry,idx)=>{
            const tr=document.createElement('tr');
            tr.className = 'leaderboard-row';
            // Empates en puntos -> "=" excepto primer miembro del empate
            let posDisplay = idx+1;
            if(idx>0 && entry.points === leaderboard[idx-1].points){ posDisplay='='; }

            const gained=pointsYesterday[entry.userId]||0;

            // Variaci√≥n de posiciones
            const currentRankNum=(posDisplay==='=')? (function(){
                // buscar rank number of first tied above
                let i=idx;
                while(i>0 && leaderboard[i-1].points===entry.points){ i--; }
                return i+1;
            })(): idx+1;
            const prevRank=prevRankMap[entry.userId]||currentRankNum;
            const diffRank=prevRank-currentRankNum; // positivo si sube

            // Medal icons for top 3
            let rankDisplay = posDisplay;
            if (currentRankNum === 1) rankDisplay = 'ü•á';
            else if (currentRankNum === 2) rankDisplay = 'ü•à';
            else if (currentRankNum === 3) rankDisplay = 'ü•â';
            else if (currentRankNum === 17) rankDisplay = 'üèÆ';
            tr.innerHTML=`
              <td class="rank-cell">
                <div class="rank-content">
                  <span class="rank-number">${rankDisplay}</span>
                  ${diffRank > 0 ? `<span class="rank-change up">‚Üë${diffRank}</span>` : diffRank < 0 ? `<span class="rank-change down">‚Üì${Math.abs(diffRank)}</span>` : ''}
                </div>
              </td>
              <td class="participant-cell">
                <a href="#pred" class="participant-link" data-userid="${entry.userId}">${entry.displayName}</a>
              </td>
              <td class="points-cell">
                <span class="total-points">${entry.points}</span>
              </td>
              <td class="progress-cell">
                ${buildSparkline(rankHistoryByUser[entry.userId], participants.length)}
              </td>
            `;
            tbody.appendChild(tr);
        });

        // Timestamp actualizado
        const updatedEl=document.getElementById('updatedAt');
        let lastDate=null;
        Object.keys(resultsById).forEach(mid=>{
            const res=resultsById[mid];
            if(res.homeGoals!==null && res.awayGoals!==null){
                const match=matchesById[mid];
                if(match){
                    const d=new Date(match.dateTime);
                    if(!lastDate || d>lastDate){ lastDate=d; }
                }
            }
        });
        if(lastDate){
            // Usar la fecha/hora del √∫ltimo partido completo y sumar 3 horas
            const ts=new Date(lastDate.getTime()+2.25*60*60*1000);
            const dateStr=formatDateEnglish(ts);
            const timeStr=ts.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',hour12:false});
            updatedEl.textContent=`Last updated: ${dateStr}, ${timeStr}`;
        }

        /* ---------- Global Stats Top 3 (para las 6 m√©tricas) ---------- */
        const globalStatsEl=document.getElementById('globalStats');
        if(globalStatsEl){
          // Precomputar m√©tricas por usuario
          const metricsByUser = {};

          const completedGroups = Object.keys(realGroupStandings).filter(g=> isGroupComplete(realGroupStandings[g]));

          participants.forEach(p => {
            const uid = p.userId;
            const userPreds = predictions.filter(pr => pr.userId===uid);
            let exact=0, sign=0, played=0, totalPtsPlayed=0;
            userPreds.forEach(pr=>{
              const res = resultsById[pr.matchId];
              if(res && res.homeGoals!==null){
                played++;
                const pts = calculateMatchPoints(pr);
                totalPtsPlayed += pts;
                if(pts===5) exact++; else if(pts===3) sign++;
              }
            });
            const avgPts = played? (totalPtsPlayed/played):0;

            let perfect=0, semi=0, oneQual=0;
            completedGroups.forEach(g=>{
              const userGs = groupStandings[uid];
              const pts = userGs && userGs[g] ? calcGroupPoints(userGs[g], realGroupStandings[g]) : 0;
              if(pts===7) perfect++; else if(pts===5) semi++; else if(pts===2) oneQual++;
            });

            metricsByUser[uid] = {displayName:p.displayName || uid, exact, sign, avgPts:parseFloat(avgPts.toFixed(2)), perfect, semi, oneQual};
          });

          const getTop = key => Object.values(metricsByUser).sort((a,b)=> b[key]-a[key]).slice(0,3);

          const metrics = [
            {key:'exact', title:'Exact scores'},
            {key:'sign', title:'Outcome hits'},
            {key:'avgPts', title:'Pts / match'},
            {key:'perfect', title:'Perfect groups'},
            {key:'semi', title:'Semi-perfect'},
            {key:'oneQual', title:'1 qualifier'}
          ];

          const matchesMetrics=['exact','sign','avgPts'];
          const groupsMetrics=['perfect','semi','oneQual'];

          const buildMetricHTML=(m)=>{
            const top=getTop(m.key);
            const itemsHtml=top.map(t=>`<li class=\"top-item\"><span class=\"name\">${t.displayName}</span><span class=\"value\">${t[m.key]}</span></li>`).join('');
            return `<div class=\"stat-set\"><div class=\"stat-set-title\">${m.title}</div><ul class=\"top-list\">${itemsHtml}</ul></div>`;
          };

          const matchesHTML=metrics.filter(m=>matchesMetrics.includes(m.key)).map(buildMetricHTML).join('');
          const groupsHTML=metrics.filter(m=>groupsMetrics.includes(m.key)).map(buildMetricHTML).join('');

          globalStatsEl.innerHTML = `
            <h3 class=\"section-title\">Overall Stats</h3>
            <div class=\"stats-block\">
              <div class=\"stats-block-title\">Matches Stats.</div>
              <div class=\"stats-group\">${matchesHTML}</div>
            </div>
            <div class=\"stats-block\">
              <div class=\"stats-block-title\">Groups Stats.</div>
              <div class=\"stats-group\">${groupsHTML}</div>
            </div>`;
        }
     }

    // Calcula puntos de clasificaci√≥n de grupo seg√∫n reglas
    function calcGroupPoints(predicted, real){
      if(!predicted || !real || predicted.length<4 || real.length<4) return 0;
      const predOrder = predicted.map(t=>t.teamName).join('|');
      const realOrder = real.map(t=>t.teamName).join('|');
      if(predOrder===realOrder){ return 7; }
      const predQual = predicted.slice(0,2).map(t=>t.teamName);
      const realQual = real.slice(0,2).map(t=>t.teamName);
      const matches = predQual.filter(n=>realQual.includes(n)).length;
      if(matches===2) return 5;
      if(matches===1) return 2;
      return 0;
    }

    // Devuelve true si un grupo termin√≥ (3 partidos cada equipo)
    function isGroupComplete(realArr){
      return realArr && realArr.length && realArr.every(t=>t.matchesPlayed===3);
    }

    /** ----------------------------------------------------------
     * NUEVA FUNCI√ìN: calcular clasificaci√≥n real a partir de resultados
     * (reglas simplificadas: puntos, diferencia de goles, goles a favor)
     * ---------------------------------------------------------*/
    function computeRealGroupStandings(matchesArr, resultsArr, teamsArr){
      const teamIdToName = Object.fromEntries(teamsArr.map(t=>[t.teamId, t.name]));
      const teamIdToGroup = Object.fromEntries(teamsArr.map(t=>[t.teamId, t.group]));
      const standings = {};
      // Agrupar por equipo -> stats base
      const statsMap = {};
      teamsArr.forEach(t=>{
        statsMap[t.teamId]={
          teamId:t.teamId,
          teamName:teamIdToName[t.teamId],
          points:0, goalsFor:0, goalsAgainst:0, goalDifference:0, matchesPlayed:0
        };
      });
      // Procesar cada resultado de fase de grupos
      matchesArr.forEach(match=>{
        if(match.phase!== 'group') return;
        const res = resultsArr.find(r=> r.matchId===match.matchId);
        if(!res || res.homeGoals===null || res.awayGoals===null) return;
        const homeStats = statsMap[match.homeTeam];
        const awayStats = statsMap[match.awayTeam];
        if(!homeStats || !awayStats) return;
        // Actualizar PJ
        homeStats.matchesPlayed++; awayStats.matchesPlayed++;
        // Goles
        homeStats.goalsFor += res.homeGoals; homeStats.goalsAgainst += res.awayGoals;
        awayStats.goalsFor += res.awayGoals; awayStats.goalsAgainst += res.homeGoals;
        // Puntos
        if(res.homeGoals>res.awayGoals){ homeStats.points+=3; }
        else if(res.homeGoals<res.awayGoals){ awayStats.points+=3; }
        else { homeStats.points+=1; awayStats.points+=1; }
      });
      // Calcular DG y agrupar por grupo
      Object.values(statsMap).forEach(st=>{
        st.goalDifference = st.goalsFor - st.goalsAgainst;
        const grp = teamIdToGroup[st.teamId];
        if(!standings[grp]) standings[grp]=[];
        standings[grp].push(st);
      });
      // ------------ ORDENAR CON CRITERIOS FIFA ------------------
      const getHeadToHeadStats=(cluster, matches, results)=>{
        const stats={};
        cluster.forEach(t=>{ stats[t.teamId]={pts:0, gf:0, ga:0, gd:0}; });
        matches.forEach(m=>{
          if(!(cluster.some(t=>t.teamId===m.homeTeam) && cluster.some(t=>t.teamId===m.awayTeam))) return;
          const res=results.find(r=>r.matchId===m.matchId);
          if(!res || res.homeGoals===null || res.awayGoals===null) return;
          const home=stats[m.homeTeam], away=stats[m.awayTeam];
          home.gf+=res.homeGoals; home.ga+=res.awayGoals;
          away.gf+=res.awayGoals; away.ga+=res.homeGoals;
          if(res.homeGoals>res.awayGoals){ home.pts+=3; }
          else if(res.homeGoals<res.awayGoals){ away.pts+=3; }
          else { home.pts+=1; away.pts+=1; }
        });
        Object.values(stats).forEach(s=>{ s.gd=s.gf-s.ga; });
        return stats;
      };

      const sortCluster=(arr, groupMatches, results)=>{
        if(arr.length<=1) return arr;
        // aplicar a) b) c)
        const h2h=getHeadToHeadStats(arr, groupMatches, results);
        arr.sort((a,b)=>{
          if(h2h[b.teamId].pts!==h2h[a.teamId].pts) return h2h[b.teamId].pts - h2h[a.teamId].pts;
          if(h2h[b.teamId].gd!==h2h[a.teamId].gd) return h2h[b.teamId].gd - h2h[a.teamId].gd;
          if(h2h[b.teamId].gf!==h2h[a.teamId].gf) return h2h[b.teamId].gf - h2h[a.teamId].gf;
          return 0;
        });
        // Comprobar si a√∫n hay empates despu√©s de c)
        for(let i=0;i<arr.length;){
          const same=[arr[i]];
          let j=i+1;
          while(j<arr.length && h2h[arr[j].teamId].pts===h2h[arr[i].teamId].pts && h2h[arr[j].teamId].gd===h2h[arr[i].teamId].gd && h2h[arr[j].teamId].gf===h2h[arr[i].teamId].gf){
            same.push(arr[j]); j++; }
          if(same.length>1){
            // aplicar d) e)
            same.sort((x,y)=>{
              if(y.goalDifference!==x.goalDifference) return y.goalDifference - x.goalDifference;
              if(y.goalsFor!==x.goalsFor) return y.goalsFor - x.goalsFor;
              return x.teamName.localeCompare(y.teamName);
            });
          }
          // reemplazar
          arr.splice(i, same.length, ...same);
          i+=same.length;
        }
        return arr;
      };

      Object.keys(standings).forEach(g=>{
        // Orden preliminar por puntos generales
        standings[g].sort((a,b)=> b.points-a.points);
        const groupMatches = matchesArr.filter(m=> m.phase==='group' && m.group===g);
        // Resolver empates
        for(let i=0;i<standings[g].length;){
          const samePts=[standings[g][i]];
          let j=i+1;
          while(j<standings[g].length && standings[g][j].points===standings[g][i].points){ samePts.push(standings[g][j]); j++; }
          if(samePts.length>1){
            sortCluster(samePts, groupMatches, resultsArr);
          }
          // reemplazar
          standings[g].splice(i, samePts.length, ...samePts);
          i+=samePts.length;
        }
        standings[g].forEach((t,idx)=> t.position=idx+1);
      });
       return standings;
    }

    /** ----------------------------------------------------------
     * NUEVO: calcular clasificaci√≥n PRONOSTICADA de cada usuario
     * ---------------------------------------------------------*/
    function computePredictedGroupStandingsForUser(userPredictions, matchesArr, teamsArr) {
      // Filtrar solo los partidos de fase de grupos con predicci√≥n
      const predResults = userPredictions
        .filter(p => {
          const match = matchesArr.find(m => m.matchId === p.matchId);
          return match && match.phase === 'group';
        })
        .map(p => ({
          matchId: p.matchId,
          homeGoals: p.predHome,
          awayGoals: p.predAway
        }));

      return computeRealGroupStandings(matchesArr, predResults, teamsArr);
    }

    function computeAllPredictedGroupStandings(matchesArr, predictionsArr, teamsArr) {
      const byUser = {};
      const predsByUser = {};
      predictionsArr.forEach(p => {
        if (!predsByUser[p.userId]) predsByUser[p.userId] = [];
        predsByUser[p.userId].push(p);
      });
      Object.keys(predsByUser).forEach(uid => {
        byUser[uid] = computePredictedGroupStandingsForUser(predsByUser[uid], matchesArr, teamsArr);
      });
      return byUser;
    }

    // Devuelve fecha en ingl√©s: 25th June
    function formatDateEnglish(date){
      const day=date.getDate();
      const suffix=(day%10===1&&day!==11)?'st':(day%10===2&&day!==12)?'nd':(day%10===3&&day!==13)?'rd':'th';
      const month=date.toLocaleString('en-GB',{month:'long'});
      return `${day}${suffix} ${month}`;
    }

    // Iniciamos la app
    loadData();

    // Eliminado el Service Worker: si hubiera uno previo, lo desregistramos
    if('serviceWorker' in navigator){
      navigator.serviceWorker.getRegistrations().then(regs=>{
        regs.forEach(r=> r.unregister());
      });
    }

    // Delegaci√≥n de clic en links de participantes para navegar a Predicciones
    document.getElementById('leaderboardTable').addEventListener('click',e=>{
      const link=e.target.closest('.participant-link');
      if(link){
        e.preventDefault();
        const uid=link.dataset.userid;
        participantSelect.value=uid;
        localStorage.setItem('lastParticipant',uid);
        showTab('pred');
      }
    });

    // Configurar secciones colapsables
    document.querySelectorAll('.collapsible-header').forEach(header=>{
      const arrow=header.querySelector('.collapse-arrow');
      const content=startContent(header);
      header.addEventListener('click',()=>{
        const isHidden=content.style.display==='none';
        content.style.display=isHidden?'':'none';
        if(arrow){ arrow.textContent=isHidden?'‚ñº':'‚ñ∂'; }
      });
    });

    function startContent(header){
      // el contenido es el siguiente elemento hermano que no sea header
      let el=header.nextElementSibling;
      while(el && el.classList.contains('section-header')){ el=el.nextElementSibling; }
      return el;
    }

    /* Estado inicial desplegado/plegado basado en fecha */
    const collapseHeader=(id, collapsed)=>{
      const hdr=document.getElementById(id);
      if(!hdr) return;
      const arrow=hdr.querySelector('.collapse-arrow');
      const content=startContent(hdr);
      if(collapsed){
        content.style.display='none';
        if(arrow) arrow.textContent='‚ñ∂';
      } else {
        content.style.display='';
        if(arrow) arrow.textContent='‚ñº';
      }
    };

    // Ajuste fijo: cerrar Group Stage y Group Classifications, abrir Knockout Stage
    collapseHeader('groupPredHeader',true);
    collapseHeader('classifHeader',true);
    collapseHeader('koPredHeader',false);

    // ---------------------------
    // Vista por fecha / por grupo
    // ---------------------------
    function setGroupPredView(view){
      groupPredView = (view==='group')?'group':'date';
      localStorage.setItem('groupPredView', groupPredView);
      console.log('Estado guardado - Vista de grupo:', groupPredView);
      const btnDate=document.getElementById('btnViewDate');
      const btnGroup=document.getElementById('btnViewGroup');
      if(btnDate){ btnDate.classList.toggle('active', groupPredView==='date'); }
      if(btnGroup){ btnGroup.classList.toggle('active', groupPredView==='group'); }
      if(dataLoaded && btnPred.classList.contains('tab-active')){
        // Re‚Äêrenderizar solo si la pesta√±a Predictions est√° activa
        displayParticipant(participantSelect.value);
      }
    }

    // Event listeners de los botones
    document.getElementById('btnViewDate').addEventListener('click',()=> setGroupPredView('date'));
    document.getElementById('btnViewGroup').addEventListener('click',()=> setGroupPredView('group'));

    // Renderizar tabla agrupada por grupo
    function renderPredTableGroup(predArray, tbody){
        tbody.innerHTML='';

        // Agrupar por letra de grupo
        const groups = {};
        predArray.forEach(p=>{
            const grp = matchesById[p.matchId]?.group || '-';
            if(!groups[grp]) groups[grp]=[];
            groups[grp].push(p);
        });

        const groupKeys = Object.keys(groups).sort();

        // Funci√≥n para calcular puntos por predicci√≥n (misma l√≥gica que antes)
        const calcPoints = (pred)=>{
            const res=resultsById[pred.matchId];
            if(res && res.homeGoals!==null){
                const diff=res.homeGoals-res.awayGoals;
                const predDiff=pred.predHome-pred.predAway;
                const matchInfo = matchesById[pred.matchId];
                
                // Para fase de knockout, verificar que los equipos predichos coincidan con los reales
                if(matchInfo && matchInfo.phase !== 'group'){
                    // Obtener equipos predichos
                    const resolveUserToken=(tok)=>{
                      if(teamIdToName[tok]) return teamIdToName[tok];
                      if(/^[12][A-H]$/i.test(tok)){
                        const pos=parseInt(tok[0],10);
                        const grp=tok[1].toUpperCase();
                        
                        // Primero intentar usar clasificaci√≥n real si est√° disponible
                        const realArr = realGroupStandings[grp];
                        const groupFinished = realArr && realArr.every(t => t.matchesPlayed === 3);
                        if(groupFinished && realArr[pos-1]){
                          return realArr[pos-1].teamName;
                        }
                        
                        // Si no hay clasificaci√≥n real o no est√° completa, usar la predicha
                        const arr=currentPredStandings[grp];
                        if(arr){
                          const found=arr.find(t=>t.position===pos);
                          if(found) return found.teamName;
                          if(arr[pos-1]) return arr[pos-1].teamName;
                        }
                      }
                      if(/^W\d+$/i.test(tok)){
                        const winnerId=getPredictedWinner(participantSelect.value, tok);
                        if(winnerId && teamIdToName[winnerId]) return teamIdToName[winnerId];
                      }
                      return tok;
                    };
                    
                    // Obtener equipos reales
                    const resolveTeamToken = (token) => {
                       if (teamIdToName[token]) return teamIdToName[token];
                       if (/^W\d+$/i.test(token)) {
                         const match = matchesById[token];
                         const res = resultsById[token];
                         if(match && res && res.homeGoals!==null && res.awayGoals!==null){
                            let winnerId=null;
                            if(res.homeGoals>res.awayGoals){ winnerId=match.homeTeam; }
                            else if(res.awayGoals>res.homeGoals){ winnerId=match.awayTeam; }
                            else {
                              // Empate en 90m - verificar E.T. y penalties
                              if(res.extraTime && res.extraTime.homeExtraTimeGoals!==null && res.extraTime.awayExtraTimeGoals!==null){
                                const totalHome = res.homeGoals + res.extraTime.homeExtraTimeGoals;
                                const totalAway = res.awayGoals + res.extraTime.awayExtraTimeGoals;
                                
                                if(totalHome > totalAway){ winnerId=match.homeTeam; }
                                else if(totalAway > totalHome){ winnerId=match.awayTeam; }
                                else {
                                  // Empate en E.T. - verificar penalties
                                  if(res.penalties && res.penalties.homePenaltyGoals!==null && res.penalties.awayPenaltyGoals!==null){
                                    if(res.penalties.homePenaltyGoals>res.penalties.awayPenaltyGoals){ winnerId=match.homeTeam; }
                                    else if(res.penalties.awayPenaltyGoals>res.penalties.homePenaltyGoals){ winnerId=match.awayTeam; }
                                  }
                                }
                              } else if(res.penalties && res.penalties.homePenaltyGoals!==null && res.penalties.awayPenaltyGoals!==null){
                                // No hay E.T. pero s√≠ penalties
                                if(res.penalties.homePenaltyGoals>res.penalties.awayPenaltyGoals){ winnerId=match.homeTeam; }
                                else if(res.penalties.awayPenaltyGoals>res.penalties.homePenaltyGoals){ winnerId=match.awayTeam; }
                              }
                            }
                            if(winnerId && teamIdToName[winnerId]) return teamIdToName[winnerId];
                         }
                       }
                       if (/^[12][A-H]$/i.test(tok)) {
                         const pos = parseInt(token[0], 10);
                         const group = token[1].toUpperCase();
                         const standingsArr = realGroupStandings[group];
                         const groupFinished = standingsArr && standingsArr.every(t => t.matchesPlayed === 3);
                         if (groupFinished && standingsArr[pos - 1]) {
                           return standingsArr[pos - 1].teamName;
                         }
                       }
                       return token;
                    };
                    
                    // Obtener placeholders originales del displayName
                    const parts = matchInfo.displayName.split(' vs ').map(s => s.trim());
                    let predHomeTok, predAwayTok;
                    if(parts.length === 2){
                      predHomeTok = parts[0];
                      predAwayTok = parts[1];
                    } else {
                      predHomeTok = matchInfo.homeTeam;
                      predAwayTok = matchInfo.awayTeam;
                    }
                    
                    const realTokHome = matchInfo.homeTeam;
                    const realTokAway = matchInfo.awayTeam;
                    
                    // Resolver nombres de equipos
                    const predHomeName = resolveUserToken(predHomeTok);
                    const predAwayName = resolveUserToken(predAwayTok);
                    const realHomeName = resolveTeamToken(realTokHome);
                    const realAwayName = resolveTeamToken(realTokAway);
                    
                    // Verificar que los equipos coincidan
                    if(predHomeName !== realHomeName || predAwayName !== realAwayName){
                        return 0; // No hay puntos si los equipos no coinciden
                    }
                }
                
                // Si llegamos aqu√≠, los equipos coinciden (o es fase de grupos)
                if(pred.predHome===res.homeGoals && pred.predAway===res.awayGoals) return 5;
                
                // Para fase de grupos: comparar solo 90m
                if(matchInfo && matchInfo.phase === 'group'){
                    if((diff===0 && predDiff===0)||(diff>0 && predDiff>0)||(diff<0 && predDiff<0)) return 3;
                } else {
                    // Para fase de knockout: comparar ganador final (incluyendo E.T. y penalties)
                    // Los equipos ya han sido verificados arriba
                    // Determinar ganador predicho
                    let predWinner = null;
                    if(pred.predHome > pred.predAway) predWinner = 'home';
                    else if(pred.predAway > pred.predHome) predWinner = 'away';
                    else {
                        // Empate en predicci√≥n - usar penalties si existen
                        if(pred.predPenalties){
                            if(pred.predPenalties.home > pred.predPenalties.away) predWinner = 'home';
                            else if(pred.predPenalties.away > pred.predPenalties.home) predWinner = 'away';
                        }
                    }
                    
                    // Determinar ganador real
                    let realWinner = null;
                    if(res.homeGoals > res.awayGoals) realWinner = 'home';
                    else if(res.awayGoals > res.homeGoals) realWinner = 'away';
                    else {
                        // Empate en 90m - verificar E.T.
                        if(res.extraTime && res.extraTime.homeExtraTimeGoals !== null && res.extraTime.awayExtraTimeGoals !== null){
                            const totalHome = res.homeGoals + res.extraTime.homeExtraTimeGoals;
                            const totalAway = res.awayGoals + res.extraTime.awayExtraTimeGoals;
                            
                            if(totalHome > totalAway) realWinner = 'home';
                            else if(totalAway > totalHome) realWinner = 'away';
                            else {
                                // Empate en E.T. - verificar penalties
                                if(res.penalties && res.penalties.homePenaltyGoals !== null && res.penalties.awayPenaltyGoals !== null){
                                    if(res.penalties.homePenaltyGoals > res.penalties.awayPenaltyGoals) realWinner = 'home';
                                    else if(res.penalties.awayPenaltyGoals > res.penalties.homePenaltyGoals) realWinner = 'away';
                                }
                            }
                        } else if(res.penalties && res.penalties.homePenaltyGoals !== null && res.penalties.awayPenaltyGoals !== null){
                            // No hay E.T. pero s√≠ penalties
                            if(res.penalties.homePenaltyGoals > res.penalties.awayPenaltyGoals) realWinner = 'home';
                            else if(res.penalties.awayPenaltyGoals > res.penalties.homePenaltyGoals) realWinner = 'away';
                        }
                    }
                    
                    // Si ambos ganadores est√°n definidos y coinciden, dar 3 puntos
                    if(predWinner && realWinner && predWinner === realWinner) return 3;
                }
            }
            return 0;
        };

        // NUEVO: calcular grupos LIVE y √∫ltimo completo
        const isGroupLive = (gKey)=>{
          const matchesAll = Object.values(matchesById).filter(m=> m.phase==='group' && m.group===gKey);
          let rec=0, miss=0;
          matchesAll.forEach(m=>{
            const res=resultsById[m.matchId];
            if(res && res.homeGoals!==null && res.awayGoals!==null){ rec++; } else { miss++; }
          });
          return rec>0 && miss>0;
        };
        const liveGroupKeys = groupKeys.filter(k=> isGroupLive(k));

        groupKeys.forEach((gKey)=>{
            const items = groups[gKey].sort((a,b)=> new Date(matchesById[a.matchId].dateTime) - new Date(matchesById[b.matchId].dateTime));

            const isInitiallyOpen = FORCE_OPEN_GROUPS.includes(gKey) || liveGroupKeys.includes(gKey);
            const arrow = isInitiallyOpen ? '‚ñº' : '‚ñ∂';
            const ptsTotal = items.reduce((sum,p)=> sum+calculateMatchPoints(p),0);
            const anyPlayedGroup = items.some(pred=>{
                const res=resultsById[pred.matchId];
                return res && res.homeGoals!==null && res.awayGoals!==null;
            });
            const ptsDisplayGrp = anyPlayedGroup ? `${ptsTotal} pts` : '-';

            const headerTr=document.createElement('tr');
            headerTr.className='day-header';
            const groupMatchesAll = Object.values(matchesById).filter(m=> m.phase==='group' && m.group===gKey);
            const todayStr = new Date().toISOString().split('T')[0];
            const isLiveGroup = groupMatchesAll.some(m=> {
              if(m.dateTime.split('T')[0] !== todayStr) return false;
              const res=resultsById[m.matchId];
              const notPlayed = !(res && res.homeGoals!==null && res.awayGoals!==null);
              return notPlayed; // partido de hoy sin resultado
            });
            const isCompleteGroup = isGroupComplete(realGroupStandings[gKey]);
            const liveBadge = isLiveGroup ? '<img src="live.svg" class="badge-icon live-icon" alt="Live"/>' : '';
            const completedBadge = isCompleteGroup ? '<img src="check.svg" class="badge-icon" alt="Completed"/>' : '';
            headerTr.innerHTML=`<td colspan="6"><div class="day-header-content"><span class="arrow">${arrow}</span><span class="date-text">Group ${gKey}</span>${liveBadge}${completedBadge}<span class="points-badge">${ptsDisplayGrp}</span></div></td>`;
            tbody.appendChild(headerTr);

            const subHeaderTr=document.createElement('tr');
            subHeaderTr.className='sub-header';
            const subHeaders=['Date','Time','Match','Pred.','Real','Pts'];
            subHeaderTr.innerHTML=subHeaders.map((h,idx)=>{
                if(idx===subHeaders.length-1){
                    const inner = anyPlayedGroup ? `${ptsDisplayGrp}` : '-';
                    return `<td class="pts-header-cell"><span class="day-total points-badge" style="display:none">${inner}</span><span class="pts-text">${anyPlayedGroup?'pts':''}</span></td>`;
                }
                return `<td>${h}</td>`;
            }).join('');
            tbody.appendChild(subHeaderTr);

            // Construir filas de partidos
            items.forEach(pred=>{
                const matchInfo=matchesById[pred.matchId];
                const date=new Date(matchInfo.dateTime);
                const timePart=date.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',hour12:false});
                const matchDate=`${timePart}`;

                const dateCell = date.toLocaleString('en-GB',{day:'numeric', month:'long'});

                const predScoreHtml = `<span class="home-score">${pred.predHome}</span><span class="score-sep">-</span><span class="away-score">${pred.predAway}</span>`;
                const res=resultsById[pred.matchId];
                
                // Construir resultado real con tiempo extra y penalties
                let realScoreHtml = '';
                if (res && res.homeGoals !== null) {
                    const homeGoals = res.homeGoals;
                    const awayGoals = res.awayGoals;
                    
                    // Para fase de grupos: solo mostrar goles de 90m verticalmente sin etiqueta
                    if (matchInfo.phase === 'group') {
                        realScoreHtml = `<div class="score-group-main">
                            <span class="home-score">${homeGoals}</span>
                            <span class="away-score">${awayGoals}</span>
                        </div>`;
                    } else {
                        // Para fase de KO: mostrar grupos completos con etiquetas
                        // Grupo 90m (siempre visible)
                        let scoreHtml = `<div class="score-group">
                            <div class="score-group-label">90m.</div>
                            <div class="score-group-main">
                                <span class="home-score">${homeGoals}</span>
                                <span class="away-score">${awayGoals}</span>
                            </div>
                        </div>`;
                        
                        // Grupo E.T. (solo si hay empate en 90m y hay tiempo extra)
                        let extraTimeHtml = '';
                        if (homeGoals === awayGoals && res.extraTime && res.extraTime.homeExtraTimeGoals !== null && res.extraTime.awayExtraTimeGoals !== null) {
                            const totalHomeGoals = homeGoals + res.extraTime.homeExtraTimeGoals;
                            const totalAwayGoals = awayGoals + res.extraTime.awayExtraTimeGoals;
                            extraTimeHtml = `<div class="extra-time-group">
                                <div class="score-group-label">120M.</div>
                                <div class="score-group-main">
                                    <span class="home-score">${totalHomeGoals}</span>
                                    <span class="away-score">${totalAwayGoals}</span>
                                </div>
                            </div>`;
                        }
                        
                        // Grupo Pen. (solo si hay empate en E.T. y hay penalties)
                        let penaltiesHtml = '';
                        if (res.extraTime && res.extraTime.homeExtraTimeGoals !== null && res.extraTime.awayExtraTimeGoals !== null) {
                            const totalHomeGoals = homeGoals + res.extraTime.homeExtraTimeGoals;
                            const totalAwayGoals = awayGoals + res.extraTime.awayExtraTimeGoals;
                            if (totalHomeGoals === totalAwayGoals && res.penalties && res.penalties.homePenaltyGoals !== null && res.penalties.awayPenaltyGoals !== null) {
                                penaltiesHtml = `<div class="penalties-group">
                                    <div class="score-group-label">Pen.</div>
                                    <div class="score-group-main">
                                        <span class="home-score">${res.penalties.homePenaltyGoals}</span>
                                        <span class="away-score">${res.penalties.awayPenaltyGoals}</span>
                                    </div>
                                </div>`;
                            }
                        }
                        
                        realScoreHtml = `<div class="result-container">${scoreHtml}${extraTimeHtml}${penaltiesHtml}</div>`;
                    }
                } else {
                    realScoreHtml = '<span class="home-score">-</span><span class="score-sep">-</span><span class="away-score">-</span>';
                }
                let points=0;
                const played = res && res.homeGoals!==null;
                if(played){
                    points = calculateMatchPoints(pred); // Usa funci√≥n central con verificaci√≥n de equipos
                }

                // Determinar texto y clase para badge de puntos
                let ptsClass='none';
                let ptsText='-';
                if(played){
                  ptsText=points.toString();
                  ptsClass = points>0? 'earned' : 'zero';
                }

                // Nombre de display
                const homeId = matchInfo.homeTeam;
                const awayId = matchInfo.awayTeam;
                const homeBadge = teamIdToBadge[homeId] ? `<img src="${teamIdToBadge[homeId]}" class="team-badge" alt="${teamIdToName[homeId] || ''} badge"/>` : '';
                const awayBadge = teamIdToBadge[awayId] ? `<img src="${teamIdToBadge[awayId]}" class="team-badge" alt="${teamIdToName[awayId] || ''} badge"/>` : '';
                const homeName = teamIdToName[homeId] || matchInfo.displayName.split(' vs ')[0];
                const awayName = teamIdToName[awayId] || matchInfo.displayName.split(' vs ')[1];
                const matchCol = `<span class=\"home-team\">${homeBadge}<span class=\"team-id\">${homeId}</span><span class=\"team-name-full\">${homeName}</span></span><span class=\"vs-sep\">vs</span><span class=\"away-team\">${awayBadge}<span class=\"team-id\">${awayId}</span><span class=\"team-name-full\">${awayName}</span></span>`;

                const rowHtml=`<td class="round-cell">${dateCell}</td><td class="time-cell">${matchDate}</td><td class="match-cell">${matchCol}</td><td class="score-cell prediction">${predScoreHtml}</td><td class="score-cell result">${realScoreHtml}</td><td class="points-cell"><span class="points-badge ${ptsClass}">${ptsText}</span></td>`;

                const tr=document.createElement('tr');
                tr.className='match-row';
                tr.innerHTML=rowHtml;
                tbody.appendChild(tr);
            });

            // Comportamiento colapsable + traslado de badge
            const toggleRows=()=>{
                let next=headerTr.nextElementSibling;
                while(next && !next.classList.contains('day-header')){
                    next.style.display = (next.style.display==='none')?'':'none';
                    next=next.nextElementSibling;
                }
            };
            const updateBadges=(expanded)=>{
                const badgeHeader=headerTr.querySelector('.points-badge');
                const badgeSub=subHeaderTr.querySelector('.day-total');
                const ptsText=subHeaderTr.querySelector('.pts-text');
                if(expanded){
                    badgeHeader.style.visibility='hidden';
                    badgeSub.style.display='inline-block';
                    if(ptsText) ptsText.style.display='none';
                } else {
                    badgeHeader.style.visibility='visible';
                    badgeSub.style.display='none';
                    if(ptsText) ptsText.style.display='inline';
                }
            };

            // Listener
            headerTr.addEventListener('click',()=>{
                toggleRows();
                const arrowSpan=headerTr.querySelector('.arrow');
                if(arrowSpan){ arrowSpan.textContent = (arrowSpan.textContent==='‚ñº')?'‚ñ∂':'‚ñº'; }
                const expanded = arrowSpan.textContent==='‚ñº';
                updateBadges(expanded);
                const badgesRowEl=headerTr.querySelector('.phase-badges-row');
                if(badgesRowEl){
                   const expanded = arrowSpan.textContent==='‚ñº';
                   badgesRowEl.style.display = expanded? 'none' : 'flex';
                }
                const badgeHeader=headerTr.querySelector('.points-badge');
                const badgeSub=subHeaderTr.querySelector('.day-total');
                const ptsText=subHeaderTr.querySelector('.pts-text');
                const isExpanded = arrowSpan.textContent==='‚ñº';
                if(isExpanded){
                    badgeHeader.style.visibility='hidden';
                    badgeSub.style.display='inline-block';
                    if(ptsText) ptsText.style.display='none';
                } else {
                    badgeHeader.style.visibility='visible';
                    badgeSub.style.display='none';
                    if(ptsText) ptsText.style.display='inline';
                }
            });

            // Estado inicial
            if(!isInitiallyOpen){
                toggleRows();
                const arrowSpan=headerTr.querySelector('.arrow');
                if(arrowSpan){ arrowSpan.textContent='‚ñ∂'; }
                updateBadges(false);
            } else {
                updateBadges(true);
            }
        });
    }

    // Relocalizar el selector fecha/grupo fuera del bloque colapsable
    document.addEventListener('DOMContentLoaded',()=>{
      const viewSwitch=document.getElementById('groupStageViewSwitch');
      const firstPredSection=document.querySelector('.predictions-section');
      if(viewSwitch && firstPredSection && firstPredSection.parentElement){
        firstPredSection.parentElement.insertBefore(viewSwitch, firstPredSection);
        // Ajuste de estilo tras moverlo
        viewSwitch.style.marginTop='20px';
      }
    });

    // Render KO predictions agrupadas por fase
    function renderPredTablePhase(predArray, tbody){
        tbody.innerHTML='';
        const phaseMap={ ro16:"Round of 16", qf:"Quarter-Finals", sf:"Semi-Finals", final:"Final" };
        const order=["ro16","qf","sf","final"];

        // Agrupar predicciones por phase
        const groups={};
        predArray.forEach(p=>{
            const ph=matchesById[p.matchId]?.phase||'other';
            if(!groups[ph]) groups[ph]=[];
            groups[ph].push(p);
        });

        const calcPoints=(pred)=>{
            const res=resultsById[pred.matchId];
            if(res && res.homeGoals!==null){
                const diff=res.homeGoals-res.awayGoals;
                const predDiff=pred.predHome-pred.predAway;
                
                // Para fase de knockout, verificar que los equipos predichos coincidan con los reales
                const matchInfo = matchesById[pred.matchId];
                if(matchInfo && matchInfo.phase !== 'group'){
                    // Obtener equipos predichos
                    const resolveUserToken=(tok)=>{
                      if(teamIdToName[tok]) return teamIdToName[tok];
                      if(/^[12][A-H]$/i.test(tok)){
                        const pos=parseInt(tok[0],10);
                        const grp=tok[1].toUpperCase();
                        
                        // Primero intentar usar clasificaci√≥n real si est√° disponible
                        const realArr = realGroupStandings[grp];
                        const groupFinished = realArr && realArr.every(t => t.matchesPlayed === 3);
                        if(groupFinished && realArr[pos-1]){
                          return realArr[pos-1].teamName;
                        }
                        
                        // Si no hay clasificaci√≥n real o no est√° completa, usar la predicha
                        const arr=currentPredStandings[grp];
                        if(arr){
                          const found=arr.find(t=>t.position===pos);
                          if(found) return found.teamName;
                          if(arr[pos-1]) return arr[pos-1].teamName;
                        }
                      }
                      if(/^W\d+$/i.test(tok)){
                        const winnerId=getPredictedWinner(participantSelect.value, tok);
                        if(winnerId && teamIdToName[winnerId]) return teamIdToName[winnerId];
                      }
                      return tok;
                    };
                    
                    // Obtener equipos reales
                    const resolveTeamToken = (token) => {
                       if (teamIdToName[token]) return teamIdToName[token];
                       if (/^W\d+$/i.test(token)) {
                         const match = matchesById[token];
                         const res = resultsById[token];
                         if(match && res && res.homeGoals!==null && res.awayGoals!==null){
                            let winnerId=null;
                            if(res.homeGoals>res.awayGoals){ winnerId=match.homeTeam; }
                            else if(res.awayGoals>res.homeGoals){ winnerId=match.awayTeam; }
                            else {
                              // Empate en 90m - verificar E.T. y penalties
                              if(res.extraTime && res.extraTime.homeExtraTimeGoals!==null && res.extraTime.awayExtraTimeGoals!==null){
                                const totalHome = res.homeGoals + res.extraTime.homeExtraTimeGoals;
                                const totalAway = res.awayGoals + res.extraTime.awayExtraTimeGoals;
                                
                                if(totalHome > totalAway){ winnerId=match.homeTeam; }
                                else if(totalAway > totalHome){ winnerId=match.awayTeam; }
                                else {
                                  // Empate en E.T. - verificar penalties
                                  if(res.penalties && res.penalties.homePenaltyGoals!==null && res.penalties.awayPenaltyGoals!==null){
                                    if(res.penalties.homePenaltyGoals>res.penalties.awayPenaltyGoals){ winnerId=match.homeTeam; }
                                    else if(res.penalties.awayPenaltyGoals>res.penalties.homePenaltyGoals){ winnerId=match.awayTeam; }
                                  }
                                }
                              } else if(res.penalties && res.penalties.homePenaltyGoals!==null && res.penalties.awayPenaltyGoals!==null){
                                // No hay E.T. pero s√≠ penalties
                                if(res.penalties.homePenaltyGoals>res.penalties.awayPenaltyGoals){ winnerId=match.homeTeam; }
                                else if(res.penalties.awayPenaltyGoals>res.penalties.homePenaltyGoals){ winnerId=match.awayTeam; }
                              }
                            }
                            if(winnerId && teamIdToName[winnerId]) return teamIdToName[winnerId];
                         }
                       }
                       if (/^[12][A-H]$/i.test(tok)) {
                         const pos = parseInt(token[0], 10);
                         const group = token[1].toUpperCase();
                         const standingsArr = realGroupStandings[group];
                         const groupFinished = standingsArr && standingsArr.every(t => t.matchesPlayed === 3);
                         if (groupFinished && standingsArr[pos - 1]) {
                           return standingsArr[pos - 1].teamName;
                         }
                       }
                       return token;
                    };
                    
                    // Obtener placeholders originales del displayName
                    const parts = matchInfo.displayName.split(' vs ').map(s => s.trim());
                    let predHomeTok, predAwayTok;
                    if(parts.length === 2){
                      predHomeTok = parts[0];
                      predAwayTok = parts[1];
                    } else {
                      predHomeTok = matchInfo.homeTeam;
                      predAwayTok = matchInfo.awayTeam;
                    }
                    
                    const realTokHome = matchInfo.homeTeam;
                    const realTokAway = matchInfo.awayTeam;
                    
                    // Resolver nombres de equipos
                    const predHomeName = resolveUserToken(predHomeTok);
                    const predAwayName = resolveUserToken(predAwayTok);
                    const realHomeName = resolveTeamToken(realTokHome);
                    const realAwayName = resolveTeamToken(realTokAway);
                    
                    // Verificar que los equipos coincidan
                    if(predHomeName !== realHomeName || predAwayName !== realAwayName){
                        return 0; // No hay puntos si los equipos no coinciden
                    }
                }
                
                // Si llegamos aqu√≠, los equipos coinciden (o es fase de grupos)
                if(pred.predHome===res.homeGoals && pred.predAway===res.awayGoals) return 5;
                if((diff===0 && predDiff===0)||(diff>0 && predDiff>0)||(diff<0 && predDiff<0)) return 3;
            }
            return 0;
        };

        order.forEach(ph=>{
            if(!groups[ph]) return;
            const items=groups[ph].sort((a,b)=> new Date(matchesById[a.matchId].dateTime)-new Date(matchesById[b.matchId].dateTime));
            const ptsTotal=items.reduce((s,p)=>s+calculateMatchPoints(p),0);
            // Build team/unknown badges for phase header (similar a vista "By Date")
            const badgeArr=[];
            
            // Funci√≥n para obtener el escudo real de un equipo usando la misma l√≥gica que las celdas
            const getRealTeamBadge = (tok) => {
                let id = null;
                
                // Si es un ID directo de equipo, usarlo
                if(teamIdToBadge[tok]){ 
                    id = tok; 
                }
                // Resolver placeholders de grupo (1A/2B)
                else if(/^[12][A-H]$/i.test(tok)){
                    const pos = parseInt(tok[0], 10);
                    const grp = tok[1].toUpperCase();
                    if (realGroupStandings[grp] && isGroupComplete(realGroupStandings[grp])) {
                        const team = realGroupStandings[grp].find(t => t.position === pos);
                        id = team ? team.teamId : null;
                    }
                }
                // Resolver placeholders de ganador (W49, W50, etc.)
                else if(/^W\d+$/i.test(tok)){
                    const res = resultsById[tok];
                    if (res && res.homeGoals !== null) {
                        const match = matchesById[tok];
                        const winnerSide = getRealWinner(res);
                        if (winnerSide) {
                            const winnerToken = winnerSide === 'home' ? match.homeTeam : match.awayTeam;
                            // Resoluci√≥n recursiva
                            return getRealTeamBadge(winnerToken);
                        }
                    }
                }
                
                let src = 'badges/unknownTeam.png';
                if(id && teamIdToBadge[id]) src = teamIdToBadge[id];
                return src;
            };
            
            const pushBadge=(tok)=>{
                const src = getRealTeamBadge(tok);
                badgeArr.push(`<img src="${src}" class="team-badge" alt="team"/>`);
            };
            
            items.forEach(p=>{
                const m = matchesById[p.matchId];
                pushBadge(m.homeTeam);
                pushBadge(m.awayTeam);
            });
            const phaseBadgesHtml = badgeArr.join('');
            const headerTr=document.createElement('tr');
            headerTr.className='day-header';
            headerTr.innerHTML=`<td colspan="8"><div class="day-header-content"><span class="arrow">‚ñº</span><span class="date-text">${phaseMap[ph]}</span><span class="points-badge">${ptsTotal} pts</span></div><div class="phase-badges-row">${phaseBadgesHtml}</div></td>`;
            tbody.appendChild(headerTr);

            // subheader
            const sub=document.createElement('tr');
            sub.className='sub-header';
            const subHs=['Date','Time','ID','Pred.','Real','Pred.','Real','Pts'];
            sub.innerHTML = subHs.map((h,i)=> i===subHs.length-1 ? `<td class="pts-header-cell"><span class="day-total points-badge" style="display:none">${ptsTotal} pts</span><span class="pts-text">pts</span></td>`:`<td>${h}</td>`).join('');
            tbody.appendChild(sub);

            items.forEach(pred=>{
                const matchInfo=matchesById[pred.matchId];
                const date=new Date(matchInfo.dateTime);
                const day=date.toLocaleString('en-GB',{day:'numeric',month:'short'});
                const time=date.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',hour12:false});
                const predScore=`${pred.predHome}-${pred.predAway}`;
                const res=resultsById[pred.matchId];
                
                // Construir resultado real con tiempo extra y penalties
                let realScore = '';
                if (res && res.homeGoals !== null) {
                    const homeGoals = res.homeGoals;
                    const awayGoals = res.awayGoals;
                    
                    // Para fase de grupos: solo mostrar goles de 90m verticalmente sin etiqueta
                    if (matchInfo.phase === 'group') {
                        realScore = `<div class="score-group-main">
                            <span class="home-score">${homeGoals}</span>
                            <span class="away-score">${awayGoals}</span>
                        </div>`;
                    } else {
                        // Para fase de KO: mostrar grupos completos con etiquetas
                        // Grupo 90m (siempre visible)
                        let scoreHtml = `<div class="score-group">
                            <div class="score-group-label">90m.</div>
                            <div class="score-group-main">
                                <span class="home-score">${homeGoals}</span>
                                <span class="away-score">${awayGoals}</span>
                            </div>
                        </div>`;
                        
                        // Grupo E.T. (solo si hay empate en 90m y hay tiempo extra)
                        let extraTimeHtml = '';
                        if (homeGoals === awayGoals && res.extraTime && res.extraTime.homeExtraTimeGoals !== null && res.extraTime.awayExtraTimeGoals !== null) {
                            const totalHomeGoals = homeGoals + res.extraTime.homeExtraTimeGoals;
                            const totalAwayGoals = awayGoals + res.extraTime.awayExtraTimeGoals;
                            extraTimeHtml = `<div class="extra-time-group">
                                <div class="score-group-label">120M.</div>
                                <div class="score-group-main">
                                    <span class="home-score">${totalHomeGoals}</span>
                                    <span class="away-score">${totalAwayGoals}</span>
                                </div>
                            </div>`;
                        }
                        
                        // Grupo Pen. (solo si hay empate en E.T. y hay penalties)
                        let penaltiesHtml = '';
                        if (res.extraTime && res.extraTime.homeExtraTimeGoals !== null && res.extraTime.awayExtraTimeGoals !== null) {
                            const totalHomeGoals = homeGoals + res.extraTime.homeExtraTimeGoals;
                            const totalAwayGoals = awayGoals + res.extraTime.awayExtraTimeGoals;
                            if (totalHomeGoals === totalAwayGoals && res.penalties && res.penalties.homePenaltyGoals !== null && res.penalties.awayPenaltyGoals !== null) {
                                penaltiesHtml = `<div class="penalties-group">
                                    <div class="score-group-label">Pen.</div>
                                    <div class="score-group-main">
                                        <span class="home-score">${res.penalties.homePenaltyGoals}</span>
                                        <span class="away-score">${res.penalties.awayPenaltyGoals}</span>
                                    </div>
                                </div>`;
                            }
                        }
                        
                        realScore = `<div class="result-container">${scoreHtml}${extraTimeHtml}${penaltiesHtml}</div>`;
                    }
                } else {
                    realScore = '-';
                }
                const points=calculateMatchPoints(pred);
                const ptsClass=!res? 'none': points>0?'earned':'zero';
                const ptsText=res? points: '-';
                const row=document.createElement('tr');
                // build de celda con distinci√≥n entre columna Predicci√≥n y Real
                const buildCell=(tok, resolved, isReal = false)=>{
                    let id = getIdFromToken(tok);
                    // Si es columna Real y el token es placeholder (1A/2B/Wxx), forzar unknown
                    if(isReal && (/^[12][A-H]$/i.test(tok) || /^W\d+/i.test(tok))){
                        id = null;
                    }
                    // Para Pred., si no encontramos id con el token original pero resolved es distinto, reintentar con resolved
                    if(!id && resolved !== tok && !isReal){
                        id = getIdFromToken(resolved);
                    }
                    let src = 'badges/unknownTeam.png';
                    if(id && teamIdToBadge[id]){ src = teamIdToBadge[id]; }
                    const badge = `<img src="${src}" class="team-badge" alt="${resolved} badge"/>`;
                    const idText = tok;
                    return `${badge}<span class="team-id">${idText}</span><span class="team-name-full">${resolved}</span>`;
                };
                const predNames=`<span class="home-team">${buildCell(matchInfo.homeTeam, resolveUserToken(matchInfo.homeTeam), false)}</span><span class="vs-sep">vs</span><span class="away-team">${buildCell(matchInfo.awayTeam, resolveUserToken(matchInfo.awayTeam), false)}</span>`;
                const realNames=`<span class="home-team">${buildCell(matchInfo.homeTeam, resolveTeamToken(matchInfo.homeTeam), true)}</span><span class="vs-sep">vs</span><span class="away-team">${buildCell(matchInfo.awayTeam, resolveTeamToken(matchInfo.awayTeam), true)}</span>`;
                row.innerHTML=`<td class="round-cell">${day}</td><td class="time-cell">${time}</td><td class="round-cell">${matchInfo.matchId}</td><td class="match-cell">${predNames}</td><td class="match-cell">${realNames}</td><td class="score-cell prediction">${predScore}</td><td class="score-cell result">${realScore}</td><td class="points-cell"><span class="points-badge ${ptsClass}">${ptsText}</span></td>`;
                tbody.appendChild(row);
            });
            // toggle collapse
            const toggle=()=>{
                let n=headerTr.nextElementSibling;
                while(n && !n.classList.contains('day-header')){ n.style.display = n.style.display==='none'? '':'none'; n=n.nextElementSibling; }
            };
            headerTr.addEventListener('click',()=>{
                toggle();
                const arr=headerTr.querySelector('.arrow');
                if(arr) arr.textContent= arr.textContent==='‚ñº'?'‚ñ∂':'‚ñº';
                const expandedNow = arr.textContent==='‚ñº';
                const badgesRow=headerTr.querySelector('.phase-badges-row');
                if(badgesRow){ badgesRow.style.display = expandedNow? 'none' : 'flex'; }
                updatePts(expandedNow);
            });
        });
    }

    // Funci√≥n local para manejar traslado de puntos
    const updatePts = (expanded)=>{
        const badgeHeader=headerTr.querySelector('.points-badge');
        const badgeSub=sub.querySelector('.day-total');
        const ptsText=sub.querySelector('.pts-text');
        if(expanded){
            badgeHeader.style.visibility='hidden';
            badgeSub.style.display='inline-block';
            if(ptsText) ptsText.style.display='none';
        } else {
            badgeHeader.style.visibility='visible';
            badgeSub.style.display='none';
            if(ptsText) ptsText.style.display='inline';
        }
    };

    /* --------------------------------------------------
       UTILIDAD: Insertar / retirar icono "Live" en headers
    --------------------------------------------------*/
    function setLiveIconOnHeader(headerEl, isLive){
      if(!headerEl) return;
      let badge = headerEl.querySelector('.live-icon');
      if(isLive){
        if(!badge){
          badge=document.createElement('img');
          badge.src='live.svg';
          badge.alt='Live';
          badge.className='badge-icon live-icon';
          // Colocamos el icono justo despu√©s del t√≠tulo del header
          const titleEl = headerEl.querySelector('.section-title') || headerEl.querySelector('h2') || headerEl.querySelector('h3');
          if(titleEl){
            titleEl.insertAdjacentElement('afterend', badge);
          } else {
            headerEl.appendChild(badge);
          }
        }
      } else {
        if(badge){ badge.remove(); }
      }
    }

    function refreshHeaderLiveIcons(){
      // Determinar si hay iconos live en los cuerpos de cada secci√≥n
      const hasGroupLive = !!(groupPredictionsBody && groupPredictionsBody.querySelector('.live-icon'));
      const hasKOLive = !!(koPredictionsBody && koPredictionsBody.querySelector('.live-icon'));
      const hasClassifLive = !!(standingsContainer && standingsContainer.querySelector('.live-icon'));

      setLiveIconOnHeader(document.getElementById('groupPredHeader'), hasGroupLive);
      setLiveIconOnHeader(document.getElementById('koPredHeader'), hasKOLive);
      setLiveIconOnHeader(document.getElementById('classifHeader'), hasClassifLive);

      // Completed badges
      const allGroupsFinished = Object.keys(realGroupStandings||{}).every(g=>isGroupComplete(realGroupStandings[g]));
      const setCompletedBadge=(hdr,isComplete)=>{
        if(!hdr) return;
        let badge = hdr.querySelector('.completed-icon');
        if(isComplete){
          if(!badge){
            badge=document.createElement('img');
            badge.src='check.svg';
            badge.alt='Completed';
            badge.className='badge-icon completed-icon';
            const titleEl = hdr.querySelector('.section-title') || hdr.querySelector('h2') || hdr.querySelector('h3');
            if(titleEl){ titleEl.insertAdjacentElement('afterend', badge); }
          }
        } else { if(badge) badge.remove(); }
      };
      setCompletedBadge(document.getElementById('groupPredHeader'), allGroupsFinished);
      setCompletedBadge(document.getElementById('classifHeader'), allGroupsFinished);

      // Despu√©s de actualizar iconos Live y Completed, ajustamos headers de KO
      if(typeof updateKnockoutHeaders==='function'){
          updateKnockoutHeaders();
      }
    }

    // A√±adir cache y funciones para calcular ganadores de KO seg√∫n predicciones
    const userWinnerCache={};
    function getPredictedWinner(userId, matchId){
      const key=`${userId}_${matchId}`;
      if(key in userWinnerCache) return userWinnerCache[key];
      const match=matchesById[matchId];
      if(!match){ userWinnerCache[key]=null; return null; }
      const pred=predictions.find(p=>p.userId===userId && p.matchId===matchId);
      if(!pred){ userWinnerCache[key]=null; return null; }
      
      // Obtener resultado real para comparar
      const realResult=resultsById[matchId];
      
      let winnerTok=null;
      
      // Si hay ganador claro en la predicci√≥n de 90m
      if(pred.predHome>pred.predAway){ 
        winnerTok=match.homeTeam; 
      }
      else if(pred.predAway>pred.predHome){ 
        winnerTok=match.awayTeam; 
      }
      else {
        // Empate en 90m predicho
        // Si hay resultado real, verificar si hay E.T. o penalties
        if(realResult && realResult.homeGoals!==null && realResult.awayGoals!==null){
          // Si hay empate en 90m real y hay E.T.
          if(realResult.homeGoals===realResult.awayGoals && realResult.extraTime && 
             realResult.extraTime.homeExtraTimeGoals!==null && realResult.extraTime.awayExtraTimeGoals!==null){
            
            const totalHomeReal = realResult.homeGoals + realResult.extraTime.homeExtraTimeGoals;
            const totalAwayReal = realResult.awayGoals + realResult.extraTime.awayExtraTimeGoals;
            
            // Si hay empate en E.T. y hay penalties
            if(totalHomeReal === totalAwayReal && realResult.penalties && 
               realResult.penalties.homePenaltyGoals!==null && realResult.penalties.awayPenaltyGoals!==null){
              
              // Usar predicci√≥n de penalties si existe
              if(pred.predPenalties){
                if(pred.predPenalties.home>pred.predPenalties.away){ winnerTok=match.homeTeam; }
                else if(pred.predPenalties.away>pred.predPenalties.home){ winnerTok=match.awayTeam; }
                else { winnerTok=match.homeTeam; } // Empate en penalties -> equipo local
              } else {
                // No hay predicci√≥n de penalties, usar equipo local por defecto
                winnerTok=match.homeTeam;
              }
            } else {
              // Hay E.T. pero no penalties, o E.T. no empata
              // Como no hay predicci√≥n de E.T., asumimos que el ganador predicho es el mismo que el real
              if(totalHomeReal > totalAwayReal){ winnerTok=match.homeTeam; }
              else if(totalAwayReal > totalHomeReal){ winnerTok=match.awayTeam; }
              else { winnerTok=match.homeTeam; } // Empate total -> equipo local
            }
          } else {
            // No hay E.T. o no hay empate en 90m real
            // Usar predicci√≥n de penalties si existe
            if(pred.predPenalties){
              if(pred.predPenalties.home>pred.predPenalties.away){ winnerTok=match.homeTeam; }
              else if(pred.predPenalties.away>pred.predPenalties.home){ winnerTok=match.awayTeam; }
              else { winnerTok=match.homeTeam; }
            } else { winnerTok=match.homeTeam; }
          }
        } else {
          // No hay resultado real a√∫n, usar predicci√≥n de penalties si existe
          if(pred.predPenalties){
            if(pred.predPenalties.home>pred.predPenalties.away){ winnerTok=match.homeTeam; }
            else if(pred.predPenalties.away>pred.predPenalties.home){ winnerTok=match.awayTeam; }
            else { winnerTok=match.homeTeam; }
          } else { winnerTok=match.homeTeam; }
        }
      }
      
      // CASO ESPECIAL: Si la predicci√≥n NO es empate pero el resultado real S√ç es empate en 90m
      // y hay E.T., entonces el ganador predicho debe ser el ganador real del E.T.
      if(realResult && realResult.homeGoals!==null && realResult.awayGoals!==null && 
         realResult.homeGoals===realResult.awayGoals && realResult.extraTime && 
         realResult.extraTime.homeExtraTimeGoals!==null && realResult.extraTime.awayExtraTimeGoals!==null){
        
        const totalHomeReal = realResult.homeGoals + realResult.extraTime.homeExtraTimeGoals;
        const totalAwayReal = realResult.awayGoals + realResult.extraTime.awayExtraTimeGoals;
        
        // Si hay ganador en E.T. (sin penalties)
        if(totalHomeReal !== totalAwayReal && (!realResult.penalties || 
           realResult.penalties.homePenaltyGoals===null || realResult.penalties.awayPenaltyGoals===null)){
          
          if(totalHomeReal > totalAwayReal){ winnerTok=match.homeTeam; }
          else { winnerTok=match.awayTeam; }
        }
        // Si hay empate en E.T. y hay penalties
        else if(totalHomeReal === totalAwayReal && realResult.penalties && 
                realResult.penalties.homePenaltyGoals!==null && realResult.penalties.awayPenaltyGoals!==null){
          
          if(realResult.penalties.homePenaltyGoals > realResult.penalties.awayPenaltyGoals){ winnerTok=match.homeTeam; }
          else { winnerTok=match.awayTeam; }
        }
      }
      
      // Resolver recursivamente si es otro placeholder
      if(/^W\d+$/i.test(winnerTok)){
        winnerTok=getPredictedWinner(userId, winnerTok);
      } else if(/^[12][A-H]$/i.test(winnerTok)){
        const teamId=getIdFromToken(winnerTok);
        if(teamId) winnerTok=teamId;
      }
      userWinnerCache[key]=winnerTok;
      return winnerTok;
    }

    // At end of displayParticipant, before return or after rendering
    // -----------------------------------------------
    // Ajuste global de colapsables tras el 28 Jun
    // Cierra grupos y abre solo KO Round-of-16
    // -----------------------------------------------
    const adjustCollapsiblesAfterRender=()=>{
      /* deprecated: handled by updateKnockoutHeaders */
      return;
    };

    adjustCollapsiblesAfterRender();

    /* ------------------------------------------------------------
       KO HEADERS AUTO-OPEN/CLOSE SEG√öN LIVE / COMPLETED / PENDIENTE
    -------------------------------------------------------------*/
    function updateKnockoutHeaders(){
      const DAY_MS = 24*60*60*1000;
      const koBody = document.getElementById('koPredictionsBody');
      if(!koBody) return;
      const headers = [...koBody.querySelectorAll('.day-header')];
      if(headers.length===0) return;

      // Helper para abrir/cerrar
      const setOpen=(hdr,open)=>{
        const arrow = hdr.querySelector('.arrow');
        const isOpen = arrow && arrow.textContent==='‚ñº';
        if(open && !isOpen) hdr.click();
        if(!open && isOpen) hdr.click();
      };

      // Determinar estados
      let nextToPlayHeader=null;
      headers.forEach(h=>{
        const dateKey=h.dataset.dateKey;
        const dayMatches = Object.values(matchesById).filter(m=> m.phase!=='group' && m.dateTime.startsWith(dateKey));
        const resStates = dayMatches.map(m=> resultsById[m.matchId]);
        const anyPlayed = resStates.some(r=> r && r.homeGoals!==null);
        const allPlayed = dayMatches.length>0 && resStates.every(r=> r && r.homeGoals!==null);
        const anyLive = dayMatches.some(m=>{
           const t=new Date(m.dateTime).getTime();
           const now=Date.now();
           const res=resultsById[m.matchId];
           const played = res && res.homeGoals!==null;
           return !played && t<=now+DAY_MS && t>=now-10*60*1000; // ventana live 24h futura y 10m pasada
        });

        h.dataset.anyPlayed=anyPlayed;
        h.dataset.allPlayed=allPlayed;
        h.dataset.anyLive=anyLive;

        if(!anyPlayed && !nextToPlayHeader){ nextToPlayHeader=h; }
      });

      // Aplicar reglas
      headers.forEach(h=>{
        const anyLive   = h.dataset.anyLive==='true';
        const allPlayed = h.dataset.allPlayed==='true';
        const dateKey   = h.dataset.dateKey;
        let keepOpenCompleted=false;
        if(allPlayed){
           const key='completed_'+dateKey;
           let ts=localStorage.getItem(key);
           if(!ts){ ts=Date.now(); localStorage.setItem(key,ts); }
           keepOpenCompleted = Date.now()-ts < DAY_MS;
        }
        const shouldOpen = anyLive; // Solo mantener abierto si hay partidos en directo
        setOpen(h, shouldOpen);
      });
    }

    // Llamamos tras render KO
    updateKnockoutHeaders();

    refreshHeaderLiveIcons();
    updateKnockoutHeaders();

    // Funci√≥n global para calcular puntos de partidos (reemplaza todas las funciones calcPoints)
    function getRealWinner(res){
        if(res.homeGoals !== res.awayGoals) return res.homeGoals > res.awayGoals ? 'home':'away';
        // Empate a 90' ‚Üí mirar pr√≥rroga
        if(res.extraTime && res.extraTime.homeExtraTimeGoals!=null){
            const tHome = res.homeGoals + res.extraTime.homeExtraTimeGoals;
            const tAway = res.awayGoals + res.extraTime.awayExtraTimeGoals;
            if(tHome !== tAway) return tHome > tAway ? 'home':'away';
        }
        // Seguimos empatados ‚Üí penalties
        if(res.penalties && res.penalties.homePenaltyGoals!=null)
            return res.penalties.homePenaltyGoals > res.penalties.awayPenaltyGoals ? 'home':'away';
        return null;      // partido a√∫n sin terminar
    }

    function getPredWinner(pred){
        if(pred.predHome !== pred.predAway) return pred.predHome > pred.predAway ? 'home':'away';
        if(pred.predPenalties) {
            const {home,away}=pred.predPenalties;
            if(home!==away) return home>away?'home':'away';
        }
        return null;      // No indic√≥ ganador
    }

    /**
     * Funci√≥n global para obtener el src del escudo de un equipo real
     * Resuelve placeholders (1A, W49, etc.) a equipos reales cuando sea posible
     */
    function getRealTeamBadge(tok) {
        let id = null;
        
        // Si es un ID directo de equipo, usarlo
        if(teamIdToBadge[tok]){ 
            id = tok; 
        }
        // Resolver placeholders de grupo (1A/2B)
        else if(/^[12][A-H]$/i.test(tok)){
            const pos = parseInt(tok[0], 10);
            const grp = tok[1].toUpperCase();
            if (realGroupStandings[grp] && isGroupComplete(realGroupStandings[grp])) {
                const team = realGroupStandings[grp].find(t => t.position === pos);
                id = team ? team.teamId : null;
            }
        }
        // Resolver placeholders de ganador (W49, W50, etc.)
        else if(/^W\d+$/i.test(tok)){
            const res = resultsById[tok];
            if (res && res.homeGoals !== null) {
                const match = matchesById[tok];
                const winnerSide = getRealWinner(res);
                if (winnerSide) {
                    const winnerToken = winnerSide === 'home' ? match.homeTeam : match.awayTeam;
                    // Resoluci√≥n recursiva
                    return getRealTeamBadge(winnerToken);
                }
            }
        }
        
        let src = 'badges/unknownTeam.png';
        if(id && teamIdToBadge[id]) src = teamIdToBadge[id];
        return src;
    }

    /***********************************************************
     * SECCI√ìN DE PUNTUACI√ìN Y L√ìGICA DE PARTIDOS - CORREGIDA
     ***********************************************************/

    /**
     * Resuelve un token de equipo (ej: '1A', 'W49') al ID del equipo REAL que corresponde.
     * @param {string} token - El placeholder del equipo.
     * @returns {string|null} - El ID del equipo o null si no se puede resolver.
     */
    function resolveRealTeamId(token) {
        if (teamIdToName[token]) return token; // Ya es un ID

        // Resolver placeholder de grupo (e.g., '1A', '2H')
        if (/^[12][A-H]$/i.test(token)) {
            const pos = parseInt(token[0], 10);
            const grp = token[1].toUpperCase();
            if (realGroupStandings[grp] && isGroupComplete(realGroupStandings[grp])) {
                const team = realGroupStandings[grp].find(t => t.position === pos);
                return team ? team.teamId : null;
            }
            return null; // El grupo no ha terminado, no se puede resolver
        }

        // Resolver placeholder de ganador de partido (e.g., 'W49')
        if (/^W\d+$/i.test(token)) {
            const res = resultsById[token];
            if (!res || res.homeGoals === null) return null; // Partido no jugado

            const match = matchesById[token];
            const winnerSide = getRealWinner(res);
            if (!winnerSide) return null;

            const winnerToken = winnerSide === 'home' ? match.homeTeam : match.awayTeam;
            // Llamada recursiva por si el ganador viene de otro placeholder
            return resolveRealTeamId(winnerToken);
        }

        return null;
    }

    /**
     * Resuelve un token de equipo (ej: '1A', 'W49') al ID del equipo que un USUARIO PREDIGO.
     * @param {string} userId - ID del participante.
     * @param {string} token - El placeholder del equipo.
     * @returns {string|null} - El ID del equipo predicho o null.
     */
    function resolvePredictedTeamId(userId, token) {
        if (teamIdToName[token]) return token; // Ya es un ID

        const userStandings = groupStandings[userId];

        if (/^[12][A-H]$/i.test(token)) {
            const pos = parseInt(token[0], 10);
            const grp = token[1].toUpperCase();
            if (userStandings && userStandings[grp]) {
                const team = userStandings[grp].find(t => t.position === pos);
                return team ? team.teamId : null;
            }
            return null;
        }

        if (/^W\d+$/i.test(token)) {
            const pred = predictions.find(p => p.userId === userId && p.matchId === token);
            if (!pred) return null;

            const match = matchesById[token];
            const winnerSide = getPredWinner(pred);
            if (!winnerSide) return null;

            const winnerToken = winnerSide === 'home' ? match.homeTeam : match.awayTeam;
            return resolvePredictedTeamId(userId, winnerToken);
        }

        return null;
    }


    /**
     * VERIFICACI√ìN KO: Comprueba si los equipos que un usuario predijo para un partido
     * de eliminatoria coinciden con los equipos que realmente jugaron.
     * @param {string} userId - ID del participante.
     * @param {object} match - El objeto del partido.
     * @returns {boolean} - True si los equipos coinciden, false si no.
     */
    function teamsCoinciden(userId, match) {
        const realHomeId = resolveRealTeamId(match.homeTeam);
        const realAwayId = resolveRealTeamId(match.awayTeam);

        const predHomeId = resolvePredictedTeamId(userId, match.homeTeam);
        const predAwayId = resolvePredictedTeamId(userId, match.awayTeam);

        //console.log('[DEBUG teamsCoinciden]', {
           // matchId: match.matchId,
           // homeTeam: match.homeTeam,
           // awayTeam: match.awayTeam,
           // realHomeId,
           // realAwayId,
           // predHomeId,
           // predAwayId,
           // realHomeName: realHomeId ? teamIdToName[realHomeId] : 'null',
           // realAwayName: realAwayId ? teamIdToName[realAwayId] : 'null',
           // predHomeName: predHomeId ? teamIdToName[predHomeId] : 'null',
           // predAwayName: predAwayId ? teamIdToName[predAwayId] : 'null'
        //}); //

        // Si alg√∫n equipo real a√∫n no est√° definido (porque los partidos previos no han terminado),
        // no penalizamos (esperamos a que se resuelva)
        if (!realHomeId || !realAwayId) {
            //console.log('[DEBUG] Equipos reales no definidos, retornando true');
            return true;
        }
        // Si alg√∫n equipo predicho no est√° definido, NO puede coincidir
        if (!predHomeId || !predAwayId) {
            //console.log('[DEBUG] Equipos predichos no definidos, retornando false');
            return false;
        }
        // Si los IDs reales y predichos est√°n definidos, la comparaci√≥n debe ser exacta.
        const coinciden = realHomeId === predHomeId && realAwayId === predAwayId;
        //console.log('[DEBUG] Comparaci√≥n final:', coinciden);
        return coinciden;
    }


    /**
     * Obtiene el equipo ganador real de la final (ID del equipo)
     */
    function getFinalWinnerTeamId(match, res) {
        const winnerSide = getRealWinner(res);
        if (!winnerSide) return null;
        
        const winnerToken = winnerSide === 'home' ? match.homeTeam : match.awayTeam;
        return resolveRealTeamId(winnerToken);
    }

    /**
     * Obtiene el equipo perdedor real de la final (ID del equipo)
     */
    function getFinalLoserTeamId(match, res) {
        const winnerSide = getRealWinner(res);
        if (!winnerSide) return null;
        
        const loserToken = winnerSide === 'home' ? match.awayTeam : match.homeTeam;
        return resolveRealTeamId(loserToken);
    }

    /**
     * Obtiene el equipo ganador predicho de la final (ID del equipo)
     */
    function getFinalPredictedWinnerTeamId(userId, match, pred) {
        const predWinnerSide = getPredWinner(pred);
        if (!predWinnerSide) return null;
        
        const predWinnerToken = predWinnerSide === 'home' ? match.homeTeam : match.awayTeam;
        return resolvePredictedTeamId(userId, predWinnerToken);
    }

    /**
     * Obtiene el equipo perdedor predicho de la final (ID del equipo)
     */
    function getFinalPredictedLoserTeamId(userId, match, pred) {
        const predWinnerSide = getPredWinner(pred);
        if (!predWinnerSide) return null;
        
        const predLoserToken = predWinnerSide === 'home' ? match.awayTeam : match.homeTeam;
        return resolvePredictedTeamId(userId, predLoserToken);
    }

    /**
     * FUNCI√ìN CENTRAL DE PUNTUACI√ìN
     * Calcula los puntos de un partido, usando la l√≥gica corregida.
     */
    function calculateMatchPoints(pred) {
        const res = resultsById[pred.matchId];
        const match = matchesById[pred.matchId];
        const isKO = match && match.phase !== 'group';
        const isFinal = match && match.phase === 'final';
        
        if (!res || res.homeGoals === null) return 0;

        // Regla KO 1.1: ¬øCoinciden los equipos? (excepto para reglas especiales de final)
        if (isKO && !isFinal && !teamsCoinciden(pred.userId, match)) {
            return 0; // Si no coinciden, 0 puntos y no se eval√∫a m√°s.
        }

        // REGLAS ESPECIALES PARA LA FINAL
        if (isFinal) {
            let totalPoints = 0;
            const teamsMatch = teamsCoinciden(pred.userId, match);
            
            // Regla mantenida: 5 puntos si el resultado en los 90 minutos es correcto 
            // siempre y cuando ambos equipos predichos coincidan con los equipos reales
            if (teamsMatch && pred.predHome === res.homeGoals && pred.predAway === res.awayGoals) {
                totalPoints += 5;
            }
            
            // Nueva regla A: Si el equipo ganador predicho coincide con el equipo ganador real, 
            // independientemente del rival en la final: 10 puntos
            const realWinnerTeamId = getFinalWinnerTeamId(match, res);
            const predWinnerTeamId = getFinalPredictedWinnerTeamId(pred.userId, match, pred);
            
            if (realWinnerTeamId && predWinnerTeamId && realWinnerTeamId === predWinnerTeamId) {
                totalPoints += 10;
            }
            
            // Nueva regla B: Si el equipo perdedor predicho coincide con el equipo perdedor real,
            // independientemente del rival en la final: 8 puntos
            const realLoserTeamId = getFinalLoserTeamId(match, res);
            const predLoserTeamId = getFinalPredictedLoserTeamId(pred.userId, match, pred);
            
            if (realLoserTeamId && predLoserTeamId && realLoserTeamId === predLoserTeamId) {
                totalPoints += 8;
            }
            
            return totalPoints;
        }

        // REGLAS NORMALES PARA OTROS PARTIDOS
        
        // Para partidos KO no finales, verificar que coincidan los equipos
        if (isKO && !teamsCoinciden(pred.userId, match)) {
            return 0;
        }

        // Regla 1 (y 1.2): 5 puntos por marcador exacto en 90m
        if (pred.predHome === res.homeGoals && pred.predAway === res.awayGoals) {
            return 5;
        }

        // Regla 2: 3 puntos por acertar el ganador/resultado
        if (!isKO) {
            // Fase de grupos (Regla 2.1)
            const diff = res.homeGoals - res.awayGoals;
            const predDiff = pred.predHome - pred.predAway;
            if ((diff === 0 && predDiff === 0) || (diff > 0 && predDiff > 0) || (diff < 0 && predDiff < 0)) {
                return 3;
            }
        } else {
            // Fase KO (Regla 2.2)
            const realW = getRealWinner(res);
            const predW = getPredWinner(pred);
            if (realW && predW && realW === predW) {
                return 3;
            }
        }
        
        return 0;
    }

  </script>
</body>
</html>