<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Predicciones Copa Mundial de Clubes 2025</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="container">
    <header class="header">
      <div class="header-content">
        <img src="k-logo.svg" alt="KingMakers" class="logo"/>
        <h1 class="main-title">2025 FIFA Club World Cup Porra</h1>
      </div>
    </header>

    <nav class="nav-tabs">
      <button id="btnClasif" class="tab-button tab-active">
        <span class="tab-icon">üèÜ</span>
        Leaderboard
      </button>
      <button id="btnPred" class="tab-button">
        <span class="tab-icon">‚öΩ</span>
        Predictions
      </button>
    </nav>

    <main class="main-content">
      <section id="predTab" class="tab-content">
        <div class="prediction-controls card">
          <div class="control-group">
            <label for="participantSelect" class="control-label">Select Participant</label>
            <select id="participantSelect" class="select-input"></select>
          </div>
          <div id="leaderSnippet" class="leader-snippet"></div>
          <h1 id="predTitle" class="section-title"></h1>
        </div>

        <div class="predictions-section">
          <div id="groupStageViewSwitch" class="view-switch" style="margin-bottom:12px; display:flex; gap:8px;">
            <button id="btnViewDate" class="toggle-btn active">By date</button>
            <button id="btnViewGroup" class="toggle-btn">By group</button>
          </div>
          <div id="groupPredHeader" class="section-header collapsible-header">
            <span class="collapse-arrow">‚ñº</span>
            <h3 class="section-title">Group Stage</h3>
            <span class="section-total" id="groupPredTotal"></span>
          </div>
          <div class="table-container">
            <table id="groupPredictionsTable" class="predictions-table">
              <!-- Cabecera eliminada; cada d√≠a a√±ade su propia sub-header -->
              <tbody id="groupPredictionsBody"></tbody>
            </table>
          </div>
        </div>

        <section id="standingsSection" class="standings-section" style="display:none;">
          <div id="classifHeader" class="section-header collapsible-header">
            <span class="collapse-arrow">‚ñº</span>
            <h2 class="section-title">Group Classifications</h2>
            <span class="section-total" id="classifTotal"></span>
          </div>
          <div id="standingsContainer" class="standings-grid"></div>
        </section>

        <div class="predictions-section">
          <div id="koPredHeader" class="section-header collapsible-header">
            <span class="collapse-arrow">‚ñº</span>
            <h3 class="section-title">Knockout Stage</h3>
            <span class="section-total" id="koPredTotal"></span>
          </div>
          <div class="table-container">
            <table id="koPredictionsTable" class="predictions-table">
              <!-- Cabecera eliminada; cada d√≠a a√±ade su propia sub-header -->
              <tbody id="koPredictionsBody"></tbody>
            </table>
          </div>
        </div>
      </section>

      <section id="clasifTab" class="tab-content" style="display:none;">
          <h1 class="section-title">Overall Leaderboard</h1>
          <p id="updatedAt" class="last-updated"></p>
        
        <div class="table-container">
          <table id="leaderboardTable" class="leaderboard-table">
            <thead>
              <tr>
                <th>Rank</th>
                <th>Points</th>
                <th>Participant</th>
                <th id="prevDayHeader">Previous Day Points</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </section>
    </main>
  </div>

  <script>
    const participantSelect = document.getElementById('participantSelect');
    const btnPred=document.getElementById('btnPred');
    const btnClasif=document.getElementById('btnClasif');
    const predTab=document.getElementById('predTab');
    const clasifTab=document.getElementById('clasifTab');
    const groupPredictionsBody = document.getElementById('groupPredictionsBody');
    const groupPredictionsTable = document.getElementById('groupPredictionsTable');
    const koPredictionsBody = document.getElementById('koPredictionsBody');
    const koPredictionsTable = document.getElementById('koPredictionsTable');
    const standingsContainer = document.getElementById('standingsContainer');
    const standingsSection = document.getElementById('standingsSection');
    const predControls=document.querySelector('.prediction-controls');
    const predTitle=document.getElementById('predTitle');

    let participants = [];
    let leaderboard = [];
    let matchesById = {};
    let predictions = [];
    let groupStandings = {};
    let realGroupStandings = {};
    let resultsById = {};
    let teamIdToName = {};
    let currentPredStandings = {}; // clasific. del usuario actual
    let groupPredView = 'date'; // 'date' o 'group'
    let dataLoaded = false;
    let pendingParticipant=null;

    async function loadData() {
      try {
        // Cargamos todos los ficheros necesarios en paralelo
        const [participantsRes, matchesRes, predictionsRes, standingsRes, resultsRes, teamsRes] = await Promise.all([
          fetch('participants.json'),
          fetch('matches.json'),
          fetch('predictions.json'),
          fetch('group-standings.json'),
          fetch('results.json'),
          fetch('teams.json')
        ]);

        participants = await participantsRes.json();
        const matchesArray = await matchesRes.json();
        predictions = await predictionsRes.json();
        groupStandings = await standingsRes.json();
        const resultsArray = await resultsRes.json();
        const teamsArray = await teamsRes.json();

        // ùó°ùó®ùóòùó©ùó¢: Recalcular clasificaci√≥n real en base a los √∫ltimos resultados
        realGroupStandings = computeRealGroupStandings(matchesArray, resultsArray, teamsArray);

        // Pasamos los arrays a diccionarios por id para lookup r√°pido
        matchesArray.forEach(m => { matchesById[m.matchId] = m; });
        resultsArray.forEach(r => { resultsById[r.matchId] = r; });

        /* --------------------------------------------------
           Calcular secciones LIVE (al menos un resultado, pero no todos)
        --------------------------------------------------*/
        const calcLive=(matchArr)=>{
          let recorded=0, missing=0;
          matchArr.forEach(m=>{
            const res=resultsById[m.matchId];
            if(res && res.homeGoals!==null && res.awayGoals!==null){ recorded++; } else { missing++; }
          });
          return recorded>0 && missing>0;
        };

        const groupMatches=matchesArray.filter(m=>m.phase==='group');
        const koMatches=matchesArray.filter(m=>m.phase!=='group');

        let liveGroup=false, liveClassif=false, liveKO=false;
        const now=new Date();
        const switchDate=new Date('2025-06-28T00:00:00+02:00'); // 28 Jun 00:00 hora espa√±ola

        if(now < switchDate){
          liveGroup = true;
          liveClassif = true;
          liveKO = false;
        } else {
          liveGroup = false;
          liveClassif = false;
          liveKO = true;
        }

        const setLiveBadge=(headerId,isLive)=>{
          const hdr=document.getElementById(headerId);
          if(!hdr) return;
          let badge=hdr.querySelector('.live-icon');
          if(isLive){
            if(!badge){
              badge=document.createElement('img');
              badge.src='live.svg';
              badge.alt='Live';
              badge.className='badge-icon live-icon';
            }
            const titleEl=hdr.querySelector('.section-title');
            if(titleEl){
              if(titleEl.nextSibling!==badge){ hdr.insertBefore(badge,titleEl.nextSibling); }
            } else {
              hdr.appendChild(badge);
            }
          } else {
            if(badge) badge.remove();
          }
        };

        setLiveBadge('groupPredHeader',liveGroup);
        setLiveBadge('classifHeader',liveClassif);
        setLiveBadge('koPredHeader',liveKO);

        teamIdToName = Object.fromEntries(teamsArray.map(t => [t.teamId, t.name]));

        // ùó°ùó®ùóòùó©ùó¢: Calcular clasificaci√≥n pronosticada para cada participante a partir de sus predicciones
        groupStandings = computeAllPredictedGroupStandings(matchesArray, predictions, teamsArray);

        // Calculamos puntos totales por participante
        const pointsByUser = {};
        predictions.forEach(pred => {
          const res = resultsArray.find(r => r.matchId === pred.matchId);
          let pts = 0;
          if (res && res.homeGoals !== null && res.awayGoals !== null) {
            const diffRes = res.homeGoals - res.awayGoals;
            const diffPred = pred.predHome - pred.predAway;
            if (pred.predHome === res.homeGoals && pred.predAway === res.awayGoals) {
              pts = 5;
            } else if ((diffRes === 0 && diffPred === 0) || (diffRes > 0 && diffPred > 0) || (diffRes < 0 && diffPred < 0)) {
              pts = 3;
            }
          }
          pointsByUser[pred.userId] = (pointsByUser[pred.userId] || 0) + pts;
        });

        // A√±adimos puntos de clasificaci√≥n de grupos
        Object.keys(groupStandings).forEach(uid=>{
          const userGroups=groupStandings[uid];
          if(!userGroups) return;
          Object.keys(userGroups).forEach(g=>{
            if(isGroupComplete(realGroupStandings[g])){
              const pts=calcGroupPoints(userGroups[g], realGroupStandings[g]);
              pointsByUser[uid]=(pointsByUser[uid]||0)+pts;
            }
          });
        });

        leaderboard = Object.entries(pointsByUser).map(([userId, pts]) => {
          const p = participants.find(pr => pr.userId === userId);
          return { userId, displayName: p ? p.displayName : userId, points: pts };
        }).sort((a, b) => b.points - a.points);

        renderLeaderboard();
        dataLoaded=true;
        if(pendingParticipant!==null){
          displayParticipant(pendingParticipant);
          pendingParticipant=null;
        }

        populateSelect();
        // Valor recordado
        const savedParticipant = localStorage.getItem('lastParticipant') || '';
        if(participantSelect.querySelector(`option[value="${savedParticipant}"]`)){
          participantSelect.value = savedParticipant;
        }
        participantSelect.addEventListener('change', () => {
          localStorage.setItem('lastParticipant', participantSelect.value);
          // Forzar que la pr√≥xima carga abra la pesta√±a de Predicciones
          localStorage.setItem('lastTab','pred');
          // Soft reload
          location.reload();
        });

        // Seleccionar pesta√±a guardada
        const savedTab = localStorage.getItem('lastTab') || 'clasif';
        showTab(savedTab);

        // Configurar vista inicial de fase de grupos (por fecha / por grupo)
        const savedView = localStorage.getItem('groupPredView') || 'date';
        setGroupPredView(savedView);
      } catch (err) {
        console.error('Error cargando datos:', err);
        alert('Hubo un problema cargando los datos. Revisa la consola para m√°s detalles.');
      }
    }

    function populateSelect() {
      // Opci√≥n por defecto vac√≠a
      const defaultOpt=document.createElement('option');
      defaultOpt.value='';
      defaultOpt.textContent='Select a participant...';
      participantSelect.appendChild(defaultOpt);
      // Resto de participantes en orden alfab√©tico
      [...participants].sort((a,b)=> a.displayName.localeCompare(b.displayName,'es',{sensitivity:'base'})).forEach(p => {
        const option = document.createElement('option');
        option.value = p.userId;
        option.textContent = p.displayName;
        participantSelect.appendChild(option);
      });
    }

    function createStandingTable(data) {
        const table = document.createElement('table');
        table.classList.add('group-table');
        
        const thead = document.createElement('thead');
        thead.innerHTML = '<tr><th>Pos</th><th>Team</th><th>MP</th><th>Pts</th><th>GF</th><th>GA</th><th>GD</th></tr>';
        table.appendChild(thead);
        
        const tbody = document.createElement('tbody');
        if (data) {
            data.forEach(team => {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td><span class="position-badge pos-${team.position}">${team.position}</span></td><td class="team-name">${team.teamName}</td><td>${team.matchesPlayed ?? '-'}</td><td class="points-cell">${team.points}</td><td>${team.goalsFor}</td><td>${team.goalsAgainst}</td><td class="goal-diff ${team.goalDifference > 0 ? 'positive' : team.goalDifference < 0 ? 'negative' : ''}">${team.goalDifference > 0 ? '+' : ''}${team.goalDifference}</td>`;
                tbody.appendChild(tr);
            });
        }
        table.appendChild(tbody);
        return table;
    }

    function displayParticipant(userId) {
      const snippetDiv=document.getElementById('leaderSnippet');
      // Referencias a headings h3 (Grupo y KO)
      const groupSection = document.querySelector('.predictions-section:first-of-type');
      const koSection = document.querySelector('.predictions-section:last-of-type');

      const predSections=document.querySelectorAll('.predictions-section');

      if(!userId){
        // Limpiar y ocultar todo
        groupPredictionsBody.innerHTML='';
        koPredictionsBody.innerHTML='';
        standingsContainer.innerHTML='';
        groupPredictionsTable.style.display='none';
        koPredictionsTable.style.display='none';
        standingsSection.style.display='none';
        if(groupSection) groupSection.style.display='none';
        if(koSection) koSection.style.display='none';
        snippetDiv.innerHTML='';
        if(predTitle){ predTitle.textContent=''; }
        predSections.forEach(sec=> sec.style.display='none');
        return;
      }

      // Asegurar que elementos est√©n visibles al seleccionar participante
      groupPredictionsTable.style.display='';
      koPredictionsTable.style.display='';
      if(groupSection) groupSection.style.display='';
      if(koSection) koSection.style.display='';
      standingsSection.style.display='block';
      
      // Obtener clasificaci√≥n de grupos pronosticada y exponerla para la fase KO
      const userStandings = groupStandings[userId];
      currentPredStandings = userStandings || {};

      // Construimos snippet prev-actual-next
      snippetDiv.innerHTML='';
      if(leaderboard.length && participants.find(p=>p.userId===userId)){
          const idx=leaderboard.findIndex(e=>e.userId===userId);
          const lines=[];
          const makeLine=(entry, bold=false)=>{
              const text=`${entry.rank}¬∫ ${entry.displayName} | ${entry.points} points`;
              return bold?`<div class="snippet-line current">${text}</div>`:`<div class="snippet-line">${text}</div>`;
          };
          leaderboard.forEach((e,i)=>{ e.rank=i+1; });
          if(idx>0){ lines.push(makeLine(leaderboard[idx-1])); }
          lines.push(makeLine(leaderboard[idx], true));
          if(idx<leaderboard.length-1){ lines.push(makeLine(leaderboard[idx+1])); }
          snippetDiv.innerHTML=lines.join('');
      }

      // 1. Mostramos predicciones de partidos
      const userPreds = predictions.filter(p => p.userId === userId);
      let groupPreds=[];
      let koPreds=[];
      groupPredictionsBody.innerHTML = '';
      koPredictionsBody.innerHTML = '';
      if (userPreds.length > 0) {
        // Ordenamos las predicciones por fecha de partido
        userPreds.sort((a, b) => {
            const dateA = new Date(matchesById[a.matchId]?.dateTime || 0);
            const dateB = new Date(matchesById[b.matchId]?.dateTime || 0);
            return dateA - dateB;
        });

        // Split predictions
        groupPreds = userPreds.filter(p => matchesById[p.matchId]?.phase === 'group');
        koPreds = userPreds.filter(p => matchesById[p.matchId] && matchesById[p.matchId].phase !== 'group');

        // Render group predictions seg√∫n la vista elegida
        if (groupPreds.length>0){
          if(groupPredView==='date'){
            renderPredTable(groupPreds, groupPredictionsBody,false);
          } else {
            renderPredTableGroup(groupPreds, groupPredictionsBody);
          }
        }

        // Render KO predictions
        if (koPreds.length>0){ renderPredTable(koPreds, koPredictionsBody,true); }

        if(groupPreds.length>0 || koPreds.length>0){ predTab.style.display='block'; } else { predTab.style.display='none'; }
      } else {
        // Si no hay predicciones pero s√≠ usuario, dejamos tablas vac√≠as
        groupPredictionsBody.innerHTML='';
        koPredictionsBody.innerHTML='';
      }
      
      // 2. Mostramos clasificaciones de grupos (predicci√≥n vs real)
      standingsContainer.innerHTML = '';
      const participant = participants.find(p => p.userId === userId);
      const userName = participant ? participant.displayName : userId;

      if (userStandings && Object.keys(realGroupStandings).length > 0) {
        Object.keys(userStandings).sort().forEach(groupKey => {
            const groupCard = document.createElement('div');
            groupCard.className = 'group-card';
            
            // Wrapper de encabezado vertical
            const headerWrap=document.createElement('div');
            headerWrap.className='group-header';

            // Fila superior (t√≠tulo + badge)
            const headerTop=document.createElement('div');
            headerTop.className='header-top';

            const groupTitle=document.createElement('h3');
            groupTitle.className='group-title';
            groupTitle.textContent=`Group ${groupKey}`;
            headerTop.appendChild(groupTitle);
            // badge se a√±adir√° despu√©s de calcularlo

            headerWrap.appendChild(headerTop);
            // placeholder for description; a√±adiremos despu√©s
            
            groupCard.appendChild(headerWrap);

            const tablesContainer = document.createElement('div');
            tablesContainer.className = 'group-tables';

            // Contenedor de dos columnas para Predicci√≥n y Actual
            const twoWrap=document.createElement('div');
            twoWrap.className='tables-wrap';

            // Columna de Predicci√≥n
            const predictedDiv = document.createElement('div');
            predictedDiv.className = 'table-column';
            const predictedTitle = document.createElement('h4');
            predictedTitle.className = 'table-subtitle';
            predictedTitle.textContent = `Prediction (${userName})`;
            predictedDiv.appendChild(predictedTitle);
            predictedDiv.appendChild(createStandingTable(userStandings[groupKey]));
            twoWrap.appendChild(predictedDiv);

            // Columna Real
            const realDiv = document.createElement('div');
            realDiv.className = 'table-column';
            const realTitle = document.createElement('h4');
            realTitle.className = 'table-subtitle';
            realTitle.textContent = 'Actual';
            realDiv.appendChild(realTitle);
            realDiv.appendChild(createStandingTable(realGroupStandings[groupKey]));
            twoWrap.appendChild(realDiv);

            /* Badge de puntos en el header */
            const badge=document.createElement('span');
            badge.className='points-badge';
            let ptsCalc=null;
            if(isGroupComplete(realGroupStandings[groupKey])){
              ptsCalc=calcGroupPoints(userStandings[groupKey], realGroupStandings[groupKey]);
              badge.textContent=`${ptsCalc} pts`;
            } else {
              badge.textContent='-';
            }
            badge.style.marginLeft='8px';
            headerTop.appendChild(badge);

            // Descripci√≥n debajo y alineada derecha
            const ptsDesc=document.createElement('div');
            ptsDesc.className='points-description';
            if(isGroupComplete(realGroupStandings[groupKey])){
              let reason='';
              switch(ptsCalc){
                case 7: reason='Perfect order prediction';break;
                case 5: reason='Both qualifiers correct';break;
                case 2: reason='One qualifier correct';break;
                default: reason='No correct predictions';
              }
              ptsDesc.textContent=reason;
            } else {
              ptsDesc.textContent='Group not finished';
            }

            headerWrap.appendChild(ptsDesc);

            // Ajustar margen inferior del header
            headerWrap.style.marginBottom='20px';

            // Estructura final: solo las dos tablas
            tablesContainer.appendChild(twoWrap);

            groupCard.appendChild(tablesContainer);
            standingsContainer.appendChild(groupCard);
        });
        predTab.style.display = 'block';
      } else {
        predTab.style.display = 'none';
      }

      // Calcular puntos por secci√≥n
      let groupStagePts=0, koStagePts=0;
      const calcPointsFn=(pred)=>{
        const res=resultsById[pred.matchId];
        if(res && res.homeGoals!==null){
          const diff=res.homeGoals-res.awayGoals;
          const predDiff=pred.predHome-pred.predAway;
          if(pred.predHome===res.homeGoals && pred.predAway===res.awayGoals){return 5;}
          if((diff===0 && predDiff===0)||(diff>0 && predDiff>0)||(diff<0 && predDiff<0)){return 3;}
        }
        return 0;
      };
      groupPreds.forEach(p=>{ groupStagePts+=calcPointsFn(p); });
      koPreds.forEach(p=>{ koStagePts+=calcPointsFn(p); });
      // Clasificaci√≥n puntos
      let classifPts=0;
      if(userStandings){
        Object.keys(userStandings).forEach(g=>{
          if(isGroupComplete(realGroupStandings[g])){
            classifPts+=calcGroupPoints(userStandings[g], realGroupStandings[g]);
          }
        });
      }
      // Actualizar spans
      const setTotal=(id,val)=>{
        const el=document.getElementById(id);
        if(el){ el.textContent=`${val} pts`; }
      };
      setTotal('groupPredTotal',groupStagePts);
      setTotal('koPredTotal',koStagePts);
      setTotal('classifTotal',classifPts);
    }

    function renderPredTable(predArray, tbody, isKO){
        tbody.innerHTML='';
        // Sort predictions by date ascending
        predArray.sort((a,b)=> new Date(matchesById[a.matchId].dateTime)- new Date(matchesById[b.matchId].dateTime));

        // Agrupamos por d√≠a (YYYY-MM-DD)
        const groups = {};
        predArray.forEach(p=>{
            const dKey = matchesById[p.matchId]?.dateTime.split('T')[0];
            if(!groups[dKey]) groups[dKey]=[];
            groups[dKey].push(p);
        });

        const dateKeys = Object.keys(groups).sort();

        // Determinar el primer d√≠a con al menos un partido sin resultado (d√≠a "LIVE")
        let ongoingDayKey = null;

        const isGroupStageComplete = !Object.values(matchesById).some(m=> m.phase==='group' && !(resultsById[m.matchId] && resultsById[m.matchId].homeGoals!==null && resultsById[m.matchId].awayGoals!==null));

        if(!isKO){
          // Fase de grupos: siempre aplicamos l√≥gica LIVE
          for(const dk of dateKeys){
            const incomplete = groups[dk].some(pred=>{
              const res = resultsById[pred.matchId];
              return !(res && res.homeGoals!==null && res.awayGoals!==null);
            });
            if(incomplete){ ongoingDayKey = dk; break; }
          }
        } else if(isGroupStageComplete){
          // Solo mostrar LIVE en KO si todos los grupos terminaron
          for(const dk of dateKeys){
            const incomplete = groups[dk].some(pred=>{
              const res = resultsById[pred.matchId];
              return !(res && res.homeGoals!==null && res.awayGoals!==null);
            });
            if(incomplete){ ongoingDayKey = dk; break; }
          }
        }

        // D√≠a inmediatamente anterior al LIVE (si existe)
        let prevDayKey = null;
        if(ongoingDayKey){
          const idx=dateKeys.indexOf(ongoingDayKey);
          if(idx>0) prevDayKey=dateKeys[idx-1];
        }

        // Funci√≥n para calcular puntos por predicci√≥n
        const calcPoints = (pred)=>{
            const res=resultsById[pred.matchId];
            if(res && res.homeGoals!==null){
                const diff=res.homeGoals-res.awayGoals;
                const predDiff=pred.predHome-pred.predAway;
                if(pred.predHome===res.homeGoals && pred.predAway===res.awayGoals){return 5;}
                if((diff===0 && predDiff===0)||(diff>0 && predDiff>0)||(diff<0 && predDiff<0)){return 3;}
            }
            return 0;
        };

        const dayPointsMap = {};
        dateKeys.forEach(k=>{
            dayPointsMap[k]=groups[k].reduce((sum,p)=> sum+calcPoints(p),0);
        });

        dateKeys.forEach(dateKey=>{
            const headerTr=document.createElement('tr');
            headerTr.className='day-header';
            const colSpan=isKO?7:6;
            const formattedDate=formatDateEnglish(new Date(dateKey));
            const isInitiallyOpen = (dateKey===ongoingDayKey) || (dateKey===prevDayKey);
            const arrow=isInitiallyOpen?'‚ñº':'‚ñ∂';
            const pts=dayPointsMap[dateKey];
            // Calcular badges
            const nowMs=Date.now();
            const liveWindow=nowMs+24*60*60*1000;
            const matchesToday=groups[dateKey];
            const allPlayedDay=matchesToday.every(pred=>{
                const res=resultsById[pred.matchId];
                return res && res.homeGoals!==null && res.awayGoals!==null;
            });
            let liveFlag=false;
            for(const pred of matchesToday){
                const info=matchesById[pred.matchId];
                const t=new Date(info.dateTime).getTime();
                const res=resultsById[pred.matchId];
                const played=res && res.homeGoals!==null && res.awayGoals!==null;
                if(!played && t>=nowMs && t<=liveWindow){ liveFlag=true; break; }
            }
            const liveBadge=liveFlag?'<img src="live.svg" class="badge-icon live-icon" alt="Live"/>':'';
            const completedBadge=(allPlayedDay && new Date(dateKey).getTime()<nowMs)?'<img src="check.svg" class="badge-icon" alt="Completed"/>':'';
            headerTr.innerHTML=`<td colspan="${colSpan}"><div class="day-header-content"><span class="arrow">${arrow}</span><span class="date-text">${formattedDate}</span>${liveBadge}${completedBadge}<span class="points-badge">${pts} pts</span></div></td>`;
            tbody.appendChild(headerTr);

            // Sub‚Äêheader con nombres de columnas para este d√≠a
            const subHeaderTr=document.createElement('tr');
            subHeaderTr.className='sub-header';
            const subHeaders=isKO?
              ['Time','Round','Pred.','Real','Pred.','Real','Pts']:
              ['Time','Round','Match','Pred.','Real','Pts'];

            subHeaderTr.innerHTML=subHeaders.map((h,idx)=>{
                if(idx===subHeaders.length-1){
                    return `<td class=\"pts-header-cell\"><span class=\"day-total points-badge\" style=\"display:none\">${pts} pts</span><span class=\"pts-text\">pts</span></td>`;
                }
                return `<td>${h}</td>`;
            }).join('');
            tbody.appendChild(subHeaderTr);

            // rows for this date
            groups[dateKey].forEach(pred=>{
                const matchInfo=matchesById[pred.matchId];
                const date=new Date(matchInfo.dateTime);
                const timePart=date.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',hour12:false});
                const matchDate=`${timePart}`;

                let roundText='-';
                switch(matchInfo.phase){case 'group':roundText=`Group ${matchInfo.group}`;break;case 'ro16':roundText='Round of 16';break;case 'qf':roundText='Quarter-Final';break;case 'sf':roundText='Semi-Final';break;case 'final':roundText='Final';break;default:roundText=matchInfo.phase;}
                // Construir versi√≥n m√≥vil/desktop
                let roundShort=''; let roundExtra='';
                if(matchInfo.phase==='group'){
                  roundShort='Grp.';
                  roundExtra=matchInfo.group; // letra del grupo
                } else {
                  switch(matchInfo.phase){
                    case 'ro16': roundShort='R16'; break;
                    case 'qf': roundShort='QF'; break;
                    case 'sf': roundShort='SF'; break;
                    case 'final': roundShort='F'; break;
                    default: roundShort=matchInfo.phase;
                  }
                  if(isKO){ roundExtra=`(${matchInfo.matchId})`; }
                }

                let roundMobile='';
                if(matchInfo.phase==='group'){
                  roundMobile=`${roundShort}<br/>${roundExtra}`; // Grp. + letra
                } else {
                  roundMobile=`${roundShort}${roundExtra?`<br/>${roundExtra}`:''}`;
                }

                // Construir contenido de escritorio: ronda + salto de l√≠nea + matchId si KO
                let roundDesktopContent=roundText;
                if(matchInfo.phase!=='group' && isKO){
                   roundDesktopContent=`${roundText}<br/><span class=\"round-id\">(${matchInfo.matchId})</span>`;
                 }
                const roundHtml=`<span class=\"round-desktop\">${roundDesktopContent}</span><span class=\"round-mobile\">${roundMobile}</span>`;

                const predScoreHtml = `<span class=\"home-score\">${pred.predHome}</span><span class=\"score-sep\">-</span><span class=\"away-score\">${pred.predAway}</span>`;
                const realScoreHtml = (resultsById[pred.matchId] && resultsById[pred.matchId].homeGoals!==null)
                  ? `<span class=\"home-score\">${resultsById[pred.matchId].homeGoals}</span><span class=\"score-sep\">-</span><span class=\"away-score\">${resultsById[pred.matchId].awayGoals}</span>`
                  : `<span class=\"home-score\">-</span><span class=\"score-sep\">-</span><span class=\"away-score\">-</span>`;
                let points=0;
                const played = (resultsById[pred.matchId] && resultsById[pred.matchId].homeGoals!==null);
                if(played){
                    const diff=resultsById[pred.matchId].homeGoals-resultsById[pred.matchId].awayGoals;
                    const predDiff=pred.predHome-pred.predAway;
                    if(pred.predHome===resultsById[pred.matchId].homeGoals && pred.predAway===resultsById[pred.matchId].awayGoals){points=5;}
                    else if((diff===0 && predDiff===0)||(diff>0 && predDiff>0)||(diff<0 && predDiff<0)){points=3;}
                }

                // Determinar texto y clase para badge de puntos
                let ptsClass='none';
                let ptsText='-';
                if(played){
                  ptsText=points.toString();
                  ptsClass = points>0? 'earned' : 'zero';
                }

                let rowHtml='';
                if(isKO){
                    const resolveUserToken=(tok)=>{
                      if(teamIdToName[tok]) return teamIdToName[tok];
                      if(/^[12][A-H]$/i.test(tok)){
                        const pos=parseInt(tok[0],10);
                        const grp=tok[1].toUpperCase();
                        const arr=currentPredStandings[grp];
                        if(arr){
                          // Buscar por la propiedad "position" para ser agn√≥stico al orden del array
                          const found=arr.find(t=>t.position===pos);
                          if(found) return found.teamName;
                          // Fallback por √≠ndice si no se encuentra
                          if(arr[pos-1]) return arr[pos-1].teamName;
                        }
                      }
                      return tok;
                    };
                    // NUEVO: obtenemos los placeholders originales del displayName
                    const parts = matchInfo.displayName.split(' vs ').map(s => s.trim());
                    let predictedName;
                    if(parts.length === 2){
                      const homeTok = parts[0];
                      const awayTok = parts[1];
                      predictedName = `${resolveUserToken(homeTok)} vs ${resolveUserToken(awayTok)}`;
                    } else {
                      predictedName = `${resolveUserToken(matchInfo.homeTeam)} vs ${resolveUserToken(matchInfo.awayTeam)}`;
                    }
                    const realName=getRealKOName(matchInfo);
                    // Convertir nombres a spans para layout responsive
                    const formatNames=(nameStr)=>{
                      const arr=nameStr.split(' vs ').map(s=>s.trim());
                      if(arr.length===2){
                        return `<span class=\"home-team\">${arr[0]}</span><span class=\"vs-sep\">vs</span><span class=\"away-team\">${arr[1]}</span>`;
                      }
                      return nameStr;
                    };
                    const predictedHtml=formatNames(predictedName);
                    const realHtml=formatNames(realName);
                    rowHtml=`<td class=\"time-cell\">${matchDate}</td><td class=\"round-cell\">${roundHtml}</td><td class=\"match-cell\">${predictedHtml}</td><td class=\"match-cell\">${realHtml}</td><td class=\"score-cell prediction\">${predScoreHtml}</td><td class=\"score-cell result\">${realScoreHtml}</td><td class=\"points-cell\"><span class=\"points-badge ${ptsClass}\">${ptsText}</span></td>`;
                } else {
                    // Fase de grupos
                    const partsName = matchInfo.displayName.split(' vs ').map(s=>s.trim());
                    const matchCol = (partsName.length===2)
                      ? `<span class=\"home-team\">${partsName[0]}</span><span class=\"vs-sep\">vs</span><span class=\"away-team\">${partsName[1]}</span>`
                      : matchInfo.displayName;
                    rowHtml=`<td class=\"time-cell\">${matchDate}</td><td class=\"round-cell\">${roundHtml}</td><td class=\"match-cell\">${matchCol}</td><td class=\"score-cell prediction\">${predScoreHtml}</td><td class=\"score-cell result\">${realScoreHtml}</td><td class=\"points-cell\"><span class=\"points-badge ${ptsClass}\">${ptsText}</span></td>`;
                }
                const tr=document.createElement('tr');
                tr.className=`match-row row-${dateKey}`;
                tr.innerHTML=rowHtml;
                tbody.appendChild(tr);
            });

            // collapsible behaviour
            const toggleRows=()=>{
                let next=headerTr.nextElementSibling;
                while(next && !next.classList.contains('day-header')){
                    next.style.display = (next.style.display==='none')?'':'none';
                    next=next.nextElementSibling;
                }
            };
            headerTr.addEventListener('click',()=>{
                toggleRows();
                const arrowSpan=headerTr.querySelector('.arrow');
                if(arrowSpan){
                    arrowSpan.textContent = (arrowSpan.textContent==='‚ñº')?'‚ñ∂':'‚ñº';
                }
                const badgeHeader=headerTr.querySelector('.points-badge');
                const badgeSub=subHeaderTr.querySelector('.day-total');
                const ptsText=subHeaderTr.querySelector('.pts-text');
                const isExpanded = arrowSpan.textContent==='‚ñº';
                if(isExpanded){
                    badgeHeader.style.visibility='hidden';
                    badgeSub.style.display='inline-block';
                    if(ptsText) ptsText.style.display='none';
                } else {
                    badgeHeader.style.visibility='visible';
                    badgeSub.style.display='none';
                    if(ptsText) ptsText.style.display='inline';
                }
            });

            // Inicialmente colapsamos si no debe estar abierto
            if(!isInitiallyOpen){
                toggleRows();
                const arrowSpan=headerTr.querySelector('.arrow');
                if(arrowSpan){ arrowSpan.textContent='‚ñ∂'; }
            } else {
                // Mostrar badge en subheader, ocultar en header
                const badgeHeader=headerTr.querySelector('.points-badge');
                const badgeSub=subHeaderTr.querySelector('.day-total');
                const ptsText=subHeaderTr.querySelector('.pts-text');
                badgeHeader.style.visibility='hidden';
                badgeSub.style.display='inline-block';
                if(ptsText) ptsText.style.display='none';
            }
        });
    }

    function resolveTeamToken(token) {
      if (teamIdToName[token]) return teamIdToName[token];
      if (/^[12][A-H]$/i.test(token)) {
        const pos = parseInt(token[0], 10);
        const group = token[1].toUpperCase();
        const standingsArr = realGroupStandings[group];
        const groupFinished = standingsArr && standingsArr.every(t => t.matchesPlayed === 3);
        if (groupFinished && standingsArr[pos - 1]) {
          return standingsArr[pos - 1].teamName;
        }
      }
      return token; // Mantener placeholder (Wxx, 1A, etc.)
    }

    function getRealKOName(match) {
      // NUEVO: resolvemos a partir de displayName para mantener placeholders cuando proceda
      const parts = match.displayName.split(' vs ').map(s => s.trim());
      if(parts.length === 2){
        const home = resolveTeamToken(parts[0]);
        const away = resolveTeamToken(parts[1]);
        return `${home} vs ${away}`;
      }
      const home = resolveTeamToken(match.homeTeam);
      const away = resolveTeamToken(match.awayTeam);
      return `${home} vs ${away}`;
    }

    function showTab(tab){
        if(tab==='pred'){
            predTab.style.display='block';
            clasifTab.style.display='none';
            standingsSection.style.display='block';
            predControls.style.display='block';
            btnPred.classList.add('tab-active');
            btnClasif.classList.remove('tab-active');
            if(dataLoaded){
              displayParticipant(participantSelect.value);
            } else {
              pendingParticipant=participantSelect.value;
            }
            predTitle.textContent='';
        } else {
            predTab.style.display='none';
            clasifTab.style.display='block';
            standingsSection.style.display='none';
            predControls.style.display='none';
            btnClasif.classList.add('tab-active');
            btnPred.classList.remove('tab-active');
            predTitle.textContent='';
        }
    }

    btnPred.addEventListener('click',()=>{ localStorage.setItem('lastTab','pred'); showTab('pred'); });
    btnClasif.addEventListener('click',()=>{ localStorage.setItem('lastTab','clasif'); showTab('clasif'); });

    function renderLeaderboard(){
        const tbody=document.querySelector('#leaderboardTable tbody');
        tbody.innerHTML='';

        // Determinar d√≠a ongoing y el inmediatamente anterior con todos los partidos finalizados
        const allDateMap={};
        Object.values(matchesById).forEach(m=>{
          const dKey=m.dateTime.split('T')[0];
          if(!allDateMap[dKey]) allDateMap[dKey]=[];
          allDateMap[dKey].push(m);
        });
        const allDateKeys=Object.keys(allDateMap).sort();
        let ongoingKey=null;
        for(const dk of allDateKeys){
          const unfinished=allDateMap[dk].some(m=>{
            const res=resultsById[m.matchId];
            return !(res && res.homeGoals!==null && res.awayGoals!==null);
          });
          if(unfinished){ ongoingKey=dk; break; }
        }
        const prevDayKey=allDateKeys[allDateKeys.indexOf(ongoingKey)-1] || null;

        // Actualizar cabecera con fecha
        const prevHeader=document.getElementById('prevDayHeader');
        if(prevHeader){
          if(prevDayKey){
            const dateObj=new Date(prevDayKey);
            const dateStr=formatDateEnglish(dateObj);
            prevHeader.textContent=`Points ${dateStr}`;
          } else {
            prevHeader.textContent='Points';
          }
        }

        // Calcular puntos obtenidos por usuario en prevDayKey
        const pointsYesterday={};
        if(prevDayKey){
          const calcPts=(pred)=>{
            const res=resultsById[pred.matchId];
            if(res && res.homeGoals!==null){
              const diff=res.homeGoals-res.awayGoals;
              const predDiff=pred.predHome-pred.predAway;
              if(pred.predHome===res.homeGoals && pred.predAway===res.awayGoals) return 5;
              if((diff===0 && predDiff===0)||(diff>0 && predDiff>0)||(diff<0 && predDiff<0)) return 3;
            }
            return 0;
          };
          predictions.forEach(pred=>{
            const match=matchesById[pred.matchId];
            if(match && match.dateTime.split('T')[0]===prevDayKey){
              pointsYesterday[pred.userId]=(pointsYesterday[pred.userId]||0)+calcPts(pred);
            }
          });
          // A√±adir puntos de grupos finalizados ese d√≠a
          Object.keys(realGroupStandings).forEach(g=>{
            const groupMatches=Object.values(matchesById).filter(m=>m.phase==='group' && m.group===g);
            const lastDate=groupMatches.reduce((max,m)=> m.dateTime>max?m.dateTime:max,'');
            if(lastDate.split('T')[0]===prevDayKey){
              participants.forEach(p=>{
                const uid=p.userId;
                const userGs=groupStandings[uid];
                if(userGs && userGs[g]){
                  const pts=calcGroupPoints(userGs[g], realGroupStandings[g]);
                  pointsYesterday[uid]=(pointsYesterday[uid]||0)+pts;
                }
              });
            }
          });
        }

        // Construir ranking del d√≠a anterior
        const prevTotals=leaderboard.map(e=>({userId:e.userId, pts:e.points-(pointsYesterday[e.userId]||0)}));
        prevTotals.sort((a,b)=> b.pts - a.pts);
        const prevRankMap={};
        let prevRankNum=1, lastPrevPts=null;
        prevTotals.forEach((item,idx)=>{
          if(idx>0 && item.pts!==lastPrevPts){ prevRankNum=idx+1; }
          prevRankMap[item.userId]=prevRankNum;
          lastPrevPts=item.pts;
        });

        leaderboard.forEach((entry,idx)=>{
            const tr=document.createElement('tr');
            tr.className = 'leaderboard-row';
            // Empates en puntos -> "=" excepto primer miembro del empate
            let posDisplay = idx+1;
            if(idx>0 && entry.points === leaderboard[idx-1].points){ posDisplay='='; }

            const gained=pointsYesterday[entry.userId]||0;

            // Variaci√≥n de posiciones
            const currentRankNum=(posDisplay==='=')? (function(){
                // buscar rank number of first tied above
                let i=idx;
                while(i>0 && leaderboard[i-1].points===entry.points){ i--; }
                return i+1;
            })(): idx+1;
            const prevRank=prevRankMap[entry.userId]||currentRankNum;
            const diffRank=prevRank-currentRankNum; // positivo si sube
            let deltaHtml='';
            if(diffRank>0){ deltaHtml=`<span class="rank-change up">‚Üë${diffRank}</span>`; }
            else if(diffRank<0){ deltaHtml=`<span class="rank-change down">‚Üì${Math.abs(diffRank)}</span>`; }

            // Medal icons for top 3
            let rankDisplay = posDisplay;
            if (currentRankNum === 1) rankDisplay = 'ü•á';
            else if (currentRankNum === 2) rankDisplay = 'ü•à';
            else if (currentRankNum === 3) rankDisplay = 'ü•â';

            tr.innerHTML=`
              <td class="rank-cell">
                <div class="rank-content">
                  <span class="rank-number">${rankDisplay}</span>
                  ${deltaHtml}
                </div>
              </td>
              <td class="points-cell">
                <span class="total-points">${entry.points}</span>
              </td>
              <td class="participant-cell">
                <a href="#pred" class="participant-link" data-userid="${entry.userId}">${entry.displayName}</a>
              </td>
              <td class="gained-cell">
                <span class="gained-points ${gained > 0 ? 'positive' : ''}">${gained > 0 ? '+' : ''}${gained}</span>
              </td>
            `;
            tbody.appendChild(tr);
        });

        // Timestamp actualizado
        const updatedEl=document.getElementById('updatedAt');
        let lastDate=null;
        Object.keys(resultsById).forEach(mid=>{
            const res=resultsById[mid];
            if(res.homeGoals!==null && res.awayGoals!==null){
                const match=matchesById[mid];
                if(match){
                    const d=new Date(match.dateTime);
                    if(!lastDate || d>lastDate){ lastDate=d; }
                }
            }
        });
        if(lastDate){
            // Usar la fecha/hora del √∫ltimo partido completo y sumar 3 horas
            const ts=new Date(lastDate.getTime()+3*60*60*1000);
            const dateStr=formatDateEnglish(ts);
            const timeStr=ts.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',hour12:false});
            updatedEl.textContent=`Last updated: ${dateStr}, ${timeStr}`;
        }
    }

    // Calcula puntos de clasificaci√≥n de grupo seg√∫n reglas
    function calcGroupPoints(predicted, real){
      if(!predicted || !real || predicted.length<4 || real.length<4) return 0;
      const predOrder = predicted.map(t=>t.teamName).join('|');
      const realOrder = real.map(t=>t.teamName).join('|');
      if(predOrder===realOrder){ return 7; }
      const predQual = predicted.slice(0,2).map(t=>t.teamName);
      const realQual = real.slice(0,2).map(t=>t.teamName);
      const matches = predQual.filter(n=>realQual.includes(n)).length;
      if(matches===2) return 5;
      if(matches===1) return 2;
      return 0;
    }

    // Devuelve true si un grupo termin√≥ (3 partidos cada equipo)
    function isGroupComplete(realArr){
      return realArr && realArr.length && realArr.every(t=>t.matchesPlayed===3);
    }

    /** ----------------------------------------------------------
     *  NUEVA FUNCI√ìN: calcular clasificaci√≥n real a partir de resultados
     *  (reglas simplificadas: puntos, diferencia de goles, goles a favor)
     * ---------------------------------------------------------*/
    function computeRealGroupStandings(matchesArr, resultsArr, teamsArr){
      const teamIdToName = Object.fromEntries(teamsArr.map(t=>[t.teamId, t.name]));
      const teamIdToGroup = Object.fromEntries(teamsArr.map(t=>[t.teamId, t.group]));
      const standings = {};
      // Agrupar por equipo -> stats base
      const statsMap = {};
      teamsArr.forEach(t=>{
        statsMap[t.teamId]={
          teamId:t.teamId,
          teamName:teamIdToName[t.teamId],
          points:0, goalsFor:0, goalsAgainst:0, goalDifference:0, matchesPlayed:0
        };
      });
      // Procesar cada resultado de fase de grupos
      matchesArr.forEach(match=>{
        if(match.phase!== 'group') return;
        const res = resultsArr.find(r=> r.matchId===match.matchId);
        if(!res || res.homeGoals===null || res.awayGoals===null) return;
        const homeStats = statsMap[match.homeTeam];
        const awayStats = statsMap[match.awayTeam];
        if(!homeStats || !awayStats) return;
        // Actualizar PJ
        homeStats.matchesPlayed++; awayStats.matchesPlayed++;
        // Goles
        homeStats.goalsFor += res.homeGoals; homeStats.goalsAgainst += res.awayGoals;
        awayStats.goalsFor += res.awayGoals; awayStats.goalsAgainst += res.homeGoals;
        // Puntos
        if(res.homeGoals>res.awayGoals){ homeStats.points+=3; }
        else if(res.homeGoals<res.awayGoals){ awayStats.points+=3; }
        else { homeStats.points+=1; awayStats.points+=1; }
      });
      // Calcular DG y agrupar por grupo
      Object.values(statsMap).forEach(st=>{
        st.goalDifference = st.goalsFor - st.goalsAgainst;
        const grp = teamIdToGroup[st.teamId];
        if(!standings[grp]) standings[grp]=[];
        standings[grp].push(st);
      });
      // Ordenar y a√±adir posici√≥n
      Object.keys(standings).forEach(g=>{
        standings[g].sort((a,b)=>{
          if(b.points!==a.points) return b.points-a.points;
          if(b.goalDifference!==a.goalDifference) return b.goalDifference-a.goalDifference;
          if(b.goalsFor!==a.goalsFor) return b.goalsFor-a.goalsFor;
          return a.teamName.localeCompare(b.teamName);
        });
        standings[g].forEach((t,idx)=> t.position = idx+1);
      });
      return standings;
    }

    /** ----------------------------------------------------------
     *  NUEVO: calcular clasificaci√≥n PRONOSTICADA de cada usuario
     * ---------------------------------------------------------*/
    function computePredictedGroupStandingsForUser(userPredictions, matchesArr, teamsArr) {
      // Filtrar solo los partidos de fase de grupos con predicci√≥n
      const predResults = userPredictions
        .filter(p => {
          const match = matchesArr.find(m => m.matchId === p.matchId);
          return match && match.phase === 'group';
        })
        .map(p => ({
          matchId: p.matchId,
          homeGoals: p.predHome,
          awayGoals: p.predAway
        }));

      return computeRealGroupStandings(matchesArr, predResults, teamsArr);
    }

    function computeAllPredictedGroupStandings(matchesArr, predictionsArr, teamsArr) {
      const byUser = {};
      const predsByUser = {};
      predictionsArr.forEach(p => {
        if (!predsByUser[p.userId]) predsByUser[p.userId] = [];
        predsByUser[p.userId].push(p);
      });
      Object.keys(predsByUser).forEach(uid => {
        byUser[uid] = computePredictedGroupStandingsForUser(predsByUser[uid], matchesArr, teamsArr);
      });
      return byUser;
    }

    // Devuelve fecha en ingl√©s: 25th June
    function formatDateEnglish(date){
      const day=date.getDate();
      const suffix=(day%10===1&&day!==11)?'st':(day%10===2&&day!==12)?'nd':(day%10===3&&day!==13)?'rd':'th';
      const month=date.toLocaleString('en-GB',{month:'long'});
      return `${day}${suffix} ${month}`;
    }

    // Iniciamos la app
    loadData();

    // Eliminado el Service Worker: si hubiera uno previo, lo desregistramos
    if('serviceWorker' in navigator){
      navigator.serviceWorker.getRegistrations().then(regs=>{
        regs.forEach(r=> r.unregister());
      });
    }

    // Delegaci√≥n de clic en links de participantes para navegar a Predicciones
    document.getElementById('leaderboardTable').addEventListener('click',e=>{
      const link=e.target.closest('.participant-link');
      if(link){
        e.preventDefault();
        const uid=link.dataset.userid;
        participantSelect.value=uid;
        localStorage.setItem('lastParticipant',uid);
        showTab('pred');
      }
    });

    // Configurar secciones colapsables
    document.querySelectorAll('.collapsible-header').forEach(header=>{
      const arrow=header.querySelector('.collapse-arrow');
      const content=startContent(header);
      header.addEventListener('click',()=>{
        const isHidden=content.style.display==='none';
        content.style.display=isHidden?'':'none';
        if(arrow){ arrow.textContent=isHidden?'‚ñº':'‚ñ∂'; }
      });
    });

    function startContent(header){
      // el contenido es el siguiente elemento hermano que no sea header
      let el=header.nextElementSibling;
      while(el && el.classList.contains('section-header')){ el=el.nextElementSibling; }
      return el;
    }

    /* Estado inicial desplegado/plegado basado en fecha */
    const collapseHeader=(id, collapsed)=>{
      const hdr=document.getElementById(id);
      if(!hdr) return;
      const arrow=hdr.querySelector('.collapse-arrow');
      const content=startContent(hdr);
      if(collapsed){
        content.style.display='none';
        if(arrow) arrow.textContent='‚ñ∂';
      } else {
        content.style.display='';
        if(arrow) arrow.textContent='‚ñº';
      }
    };

    const now=new Date();
    const switchDate=new Date('2025-06-28T00:00:00+02:00');
    if(now >= switchDate){
      /* Despu√©s del switch: solo KO abierto */
      collapseHeader('groupPredHeader',true);
      collapseHeader('classifHeader',true);
      collapseHeader('koPredHeader',false);
    } /* antes: todo abierto, no hacemos nada */

    // ---------------------------
    // Vista por fecha / por grupo
    // ---------------------------
    function setGroupPredView(view){
      groupPredView = (view==='group')?'group':'date';
      localStorage.setItem('groupPredView', groupPredView);
      const btnDate=document.getElementById('btnViewDate');
      const btnGroup=document.getElementById('btnViewGroup');
      if(btnDate){ btnDate.classList.toggle('active', groupPredView==='date'); }
      if(btnGroup){ btnGroup.classList.toggle('active', groupPredView==='group'); }
      if(dataLoaded){
        // Re‚Äêrenderizar sin cambiar participante
        displayParticipant(participantSelect.value);
      }
    }

    // Event listeners de los botones
    document.getElementById('btnViewDate').addEventListener('click',()=> setGroupPredView('date'));
    document.getElementById('btnViewGroup').addEventListener('click',()=> setGroupPredView('group'));

    // Renderizar tabla agrupada por grupo
    function renderPredTableGroup(predArray, tbody){
        tbody.innerHTML='';

        // Agrupar por letra de grupo
        const groups = {};
        predArray.forEach(p=>{
            const grp = matchesById[p.matchId]?.group || '-';
            if(!groups[grp]) groups[grp]=[];
            groups[grp].push(p);
        });

        const groupKeys = Object.keys(groups).sort();

        // Funci√≥n para calcular puntos por predicci√≥n (misma l√≥gica que antes)
        const calcPoints = (pred)=>{
            const res=resultsById[pred.matchId];
            if(res && res.homeGoals!==null){
                const diff=res.homeGoals-res.awayGoals;
                const predDiff=pred.predHome-pred.predAway;
                if(pred.predHome===res.homeGoals && pred.predAway===res.awayGoals){return 5;}
                if((diff===0 && predDiff===0)||(diff>0 && predDiff>0)||(diff<0 && predDiff<0)){return 3;}
            }
            return 0;
        };

        // Determinar √≠ndices de grupos a mostrar abiertos
        const incompleteIdxs = groupKeys
          .map((k,idx)=> isGroupComplete(realGroupStandings[k])? null : idx)
          .filter(idx=> idx!==null)
          .slice(0,2); // primeros dos grupos sin completar

        groupKeys.forEach((gKey,idx)=>{
            const items = groups[gKey].sort((a,b)=> new Date(matchesById[a.matchId].dateTime) - new Date(matchesById[b.matchId].dateTime));

            const isInitiallyOpen = incompleteIdxs.includes(idx);
            
            const ptsTotal = items.reduce((sum,p)=> sum+calcPoints(p),0);

            const headerTr=document.createElement('tr');
            headerTr.className='day-header';
            const groupMatchesAll = Object.values(matchesById).filter(m=> m.phase==='group' && m.group===gKey);
            const nowMs = Date.now();
            const liveWindow = nowMs + 24*60*60*1000;
            const isLiveGroup = groupMatchesAll.some(m=>{
                const d = new Date(m.dateTime).getTime();
                const res = resultsById[m.matchId];
                const played = res && res.homeGoals!==null && res.awayGoals!==null;
                return d >= nowMs && d <= liveWindow && !played;
            });
            const liveBadge = isLiveGroup ? '<img src="live.svg" class="badge-icon live-icon" alt="Live"/>' : '';
            const completedBadge = isGroupComplete(realGroupStandings[gKey]) ? '<img src="check.svg" class="badge-icon" alt="Completed"/>' : '';
            headerTr.innerHTML=`<td colspan="6"><div class="day-header-content"><span class="arrow">‚ñº</span><span class="date-text">Group ${gKey}</span>${liveBadge}${completedBadge}<span class="points-badge">${ptsTotal} pts</span></div></td>`;
            tbody.appendChild(headerTr);

            const subHeaderTr=document.createElement('tr');
            subHeaderTr.className='sub-header';
            const subHeaders=['Date','Time','Match','Pred.','Real','Pts'];
            subHeaderTr.innerHTML=subHeaders.map((h,idx)=>{
                if(idx===subHeaders.length-1){
                    return `<td class="pts-header-cell"><span class="day-total points-badge" style="display:none">${ptsTotal} pts</span><span class="pts-text">pts</span></td>`;
                }
                return `<td>${h}</td>`;
            }).join('');
            tbody.appendChild(subHeaderTr);

            // Construir filas de partidos
            items.forEach(pred=>{
                const matchInfo=matchesById[pred.matchId];
                const date=new Date(matchInfo.dateTime);
                const timePart=date.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',hour12:false});
                const matchDate=`${timePart}`;

                const dateCell = date.toLocaleString('en-GB',{day:'numeric', month:'long'});

                const predScoreHtml = `<span class="home-score">${pred.predHome}</span><span class="score-sep">-</span><span class="away-score">${pred.predAway}</span>`;
                const res=resultsById[pred.matchId];
                const realScoreHtml = (res && res.homeGoals!==null)
                  ? `<span class="home-score">${res.homeGoals}</span><span class="score-sep">-</span><span class="away-score">${res.awayGoals}</span>`
                  : `<span class="home-score">-</span><span class="score-sep">-</span><span class="away-score">-</span>`;

                // Calcular puntos
                const points=calcPoints(pred);
                let ptsClass='none';
                let ptsText='-';
                const played = res && res.homeGoals!==null;
                if(played){
                    ptsText=points.toString();
                    ptsClass = points>0? 'earned':'zero';
                }

                // Nombre de display
                const partsName = matchInfo.displayName.split(' vs ').map(s=>s.trim());
                const matchCol = (partsName.length===2)
                  ? `<span class="home-team">${partsName[0]}</span><span class="vs-sep">vs</span><span class="away-team">${partsName[1]}</span>`
                  : matchInfo.displayName;

                const rowHtml=`<td class="round-cell">${dateCell}</td><td class="time-cell">${matchDate}</td><td class="match-cell">${matchCol}</td><td class="score-cell prediction">${predScoreHtml}</td><td class="score-cell result">${realScoreHtml}</td><td class="points-cell"><span class="points-badge ${ptsClass}">${ptsText}</span></td>`;

                const tr=document.createElement('tr');
                tr.className='match-row';
                tr.innerHTML=rowHtml;
                tbody.appendChild(tr);
            });

            // Comportamiento colapsable + traslado de badge
            const toggleRows=()=>{
                let next=headerTr.nextElementSibling;
                while(next && !next.classList.contains('day-header')){
                    next.style.display = (next.style.display==='none')?'':'none';
                    next=next.nextElementSibling;
                }
            };
            const updateBadges=(expanded)=>{
                const badgeHeader=headerTr.querySelector('.points-badge');
                const badgeSub=subHeaderTr.querySelector('.day-total');
                const ptsText=subHeaderTr.querySelector('.pts-text');
                if(expanded){
                    badgeHeader.style.visibility='hidden';
                    badgeSub.style.display='inline-block';
                    if(ptsText) ptsText.style.display='none';
                } else {
                    badgeHeader.style.visibility='visible';
                    badgeSub.style.display='none';
                    if(ptsText) ptsText.style.display='inline';
                }
            };

            // Listener
            headerTr.addEventListener('click',()=>{
                toggleRows();
                const arrowSpan=headerTr.querySelector('.arrow');
                if(arrowSpan){ arrowSpan.textContent = (arrowSpan.textContent==='‚ñº')?'‚ñ∂':'‚ñº'; }
                const expanded = arrowSpan.textContent==='‚ñº';
                updateBadges(expanded);
            });

            // Estado inicial
            if(!isInitiallyOpen){
                toggleRows();
                const arrowSpan=headerTr.querySelector('.arrow');
                if(arrowSpan){ arrowSpan.textContent='‚ñ∂'; }
                updateBadges(false);
            } else {
                updateBadges(true);
            }
        });
    }
  </script>
</body>
</html>
