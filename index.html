<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Predicciones Copa Mundial de Clubes 2025</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="container">
    <header class="header">
      <div class="header-content">
        <img src="k-logo.svg" alt="KingMakers" class="logo"/>
        <h1 class="main-title">2025 FIFA Club World Cup Porra</h1>
      </div>
    </header>

    <nav class="nav-tabs">
      <button id="btnClasif" class="tab-button tab-active">
        <span class="tab-icon">üèÜ</span>
        Leaderboard
      </button>
      <button id="btnPred" class="tab-button">
        <span class="tab-icon">‚öΩ</span>
        Predictions
      </button>
    </nav>

    <main class="main-content">
      <section id="predTab" class="tab-content">
        <div class="prediction-controls card">
          <div class="control-group">
            <label for="participantSelect" class="control-label">Select Participant</label>
            <select id="participantSelect" class="select-input"></select>
          </div>
          <div class="leader-extra">
            <div id="leaderSnippet" class="leader-snippet"></div>
            <div id="leaderStats" class="leader-stats"></div>
          </div>
          <h1 id="predTitle" class="section-title"></h1>
        </div>

        <div class="predictions-section">
          <div id="groupStageViewSwitch" class="view-switch" style="margin-bottom:24px; display:flex; gap:8px;">
            <button id="btnViewDate" class="toggle-btn active">By date</button>
            <button id="btnViewGroup" class="toggle-btn">By group</button>
          </div>
          <div id="groupPredHeader" class="section-header collapsible-header">
            <span class="collapse-arrow">‚ñº</span>
            <h3 class="section-title">Group Stage</h3>
            <span class="section-total" id="groupPredTotal"></span>
          </div>
          <div class="table-container">
            <table id="groupPredictionsTable" class="predictions-table">
              <!-- Cabecera eliminada; cada d√≠a a√±ade su propia sub-header -->
              <tbody id="groupPredictionsBody"></tbody>
            </table>
          </div>
        </div>

        <section id="standingsSection" class="standings-section" style="display:none;">
          <div id="classifHeader" class="section-header collapsible-header">
            <span class="collapse-arrow">‚ñº</span>
            <h2 class="section-title">Group Classifications</h2>
            <span class="section-total" id="classifTotal"></span>
          </div>
          <div id="standingsContainer" class="standings-grid"></div>
        </section>

        <div class="predictions-section">
          <div id="koPredHeader" class="section-header collapsible-header">
            <span class="collapse-arrow">‚ñº</span>
            <h3 class="section-title">Knockout Stage</h3>
            <span class="section-total" id="koPredTotal"></span>
          </div>
          <div class="table-container">
            <table id="koPredictionsTable" class="predictions-table">
              <!-- Cabecera eliminada; cada d√≠a a√±ade su propia sub-header -->
              <tbody id="koPredictionsBody"></tbody>
            </table>
          </div>
        </div>
      </section>

      <section id="clasifTab" class="tab-content" style="display:none;">
          <div class="leaderboard-area">
            <div class="table-container">
              <h3 class="section-title">Overall Leaderboard</h3>
              <p id="updatedAt" class="last-updated"></p>
              <table id="leaderboardTable" class="leaderboard-table">
                <thead>
                  <tr>
                    <th>#</th>
                    <th>Name</th>
                    <th>Pts</th>
                    <th class="progress-header">Form</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
            <div id="globalStats" class="overall-stats"></div>
          </div>
      </section>
    </main>
  </div>

  <script>
    const participantSelect = document.getElementById('participantSelect');
    const btnPred=document.getElementById('btnPred');
    const btnClasif=document.getElementById('btnClasif');
    const predTab=document.getElementById('predTab');
    const clasifTab=document.getElementById('clasifTab');
    const groupPredictionsBody = document.getElementById('groupPredictionsBody');
    const groupPredictionsTable = document.getElementById('groupPredictionsTable');
    const koPredictionsBody = document.getElementById('koPredictionsBody');
    const koPredictionsTable = document.getElementById('koPredictionsTable');
    const standingsContainer = document.getElementById('standingsContainer');
    const standingsSection = document.getElementById('standingsSection');
    const predControls=document.querySelector('.prediction-controls');
    const predTitle=document.getElementById('predTitle');

    let participants = [];
    let leaderboard = [];
    let matchesById = {};
    let predictions = [];
    let groupStandings = {};
    let realGroupStandings = {};
    let resultsById = {};
    let teamIdToName = {};
    let teamIdToBadge = {};
    let currentPredStandings = {}; // clasific. del usuario actual
    let groupPredView = 'date'; // 'date' o 'group'
    let dataLoaded = false;
    let pendingParticipant=null;
    let nameToId = {};
    // Forzar aperturas espec√≠ficas solicitadas
    const FORCE_OPEN_DAYS=['2025-06-26','2025-06-27']; // Fechas que deben mostrarse expandidas en vista "By date"
    const FORCE_OPEN_GROUPS=['G','H']; // Grupos que deben mostrarse expandidos en vistas por grupo y clasificaci√≥n

    function getIdFromToken(tok){
      if(teamIdToBadge[tok]) return tok; // ya es ID
      if(nameToId[tok]) return nameToId[tok]; // es nombre
      // placeholder tipo 1A o 2B usando clasificaci√≥n PRONOSTICADA actual
      if(/^[12][A-H]$/i.test(tok)){
        const pos=parseInt(tok[0],10);
        const grp=tok[1].toUpperCase();
        const arr=currentPredStandings[grp];
        if(arr && arr[pos-1]) return arr[pos-1].teamId;
      }
      return null;
    }

    // Resuelve un token (teamId, nombre, placeholder 1A) al nombre de equipo pronosticado
    function resolveUserToken(token){
      if(teamIdToName[token]) return teamIdToName[token];
      if(/^[12][A-H]$/i.test(token)){
         const pos=parseInt(token[0],10);
         const grp=token[1].toUpperCase();
         const arr=currentPredStandings[grp];
         if(arr && arr[pos-1]) return arr[pos-1].teamName;
      }
      return token;
    }

    async function loadData() {
      try {
        // Cargamos todos los ficheros necesarios en paralelo
        const [participantsRes, matchesRes, predictionsRes, standingsRes, resultsRes, teamsRes] = await Promise.all([
          fetch('participants.json'),
          fetch('matches.json'),
          fetch('predictions.json'),
          fetch('group-standings.json'),
          fetch('results.json'),
          fetch('teams.json')
        ]);

        participants = await participantsRes.json();
        const matchesArray = await matchesRes.json();
        predictions = await predictionsRes.json();
        groupStandings = await standingsRes.json();
        const resultsArray = await resultsRes.json();
        const teamsArray = await teamsRes.json();

        // ùó°ùó®ùóòùó©ùó¢: Recalcular clasificaci√≥n real en base a los √∫ltimos resultados
        realGroupStandings = computeRealGroupStandings(matchesArray, resultsArray, teamsArray);

        // Pasamos los arrays a diccionarios por id para lookup r√°pido
        matchesArray.forEach(m => { matchesById[m.matchId] = m; });
        resultsArray.forEach(r => { resultsById[r.matchId] = r; });

        /* --------------------------------------------------
           Calcular secciones LIVE (al menos un resultado, pero no todos)
        --------------------------------------------------*/
        const calcLive=(matchArr)=>{
          let recorded=0, missing=0;
          matchArr.forEach(m=>{
            const res=resultsById[m.matchId];
            if(res && res.homeGoals!==null && res.awayGoals!==null){ recorded++; } else { missing++; }
          });
          return recorded>0 && missing>0;
        };

        const groupMatches=matchesArray.filter(m=>m.phase==='group');
        const koMatches=matchesArray.filter(m=>m.phase!=='group');

        let liveGroup=false, liveClassif=false, liveKO=false;
        const now=new Date();
        const switchDate=new Date('2025-06-28T00:00:00+02:00'); // 28 Jun 00:00 hora espa√±ola

        if(now < switchDate){
          liveGroup = true;
          liveClassif = true;
          liveKO = false;
        } else {
          liveGroup = false;
          liveClassif = false;
          liveKO = true;
        }

        const setLiveBadge=(headerId,isLive)=>{
          const hdr=document.getElementById(headerId);
          if(!hdr) return;
          let badge=hdr.querySelector('.live-icon');
          if(isLive){
            if(!badge){
              badge=document.createElement('img');
              badge.src='live.svg';
              badge.alt='Live';
              badge.className='badge-icon live-icon';
            }
            const titleEl=hdr.querySelector('.section-title');
            if(titleEl){
              if(titleEl.nextSibling!==badge){ hdr.insertBefore(badge,titleEl.nextSibling); }
            } else {
              hdr.appendChild(badge);
            }
          } else {
            if(badge) badge.remove();
          }
        };

        setLiveBadge('groupPredHeader',liveGroup);
        setLiveBadge('classifHeader',liveClassif);
        setLiveBadge('koPredHeader',liveKO);

        teamIdToName = Object.fromEntries(teamsArray.map(t => [t.teamId, t.name]));
        teamIdToBadge = Object.fromEntries(teamsArray.map(t => [t.teamId, t.badge || '']));

        nameToId = Object.fromEntries(teamsArray.map(t=>[t.name, t.teamId]));

        // ùó°ùó®ùóòùó©ùó¢: Calcular clasificaci√≥n pronosticada para cada participante a partir de sus predicciones
        groupStandings = computeAllPredictedGroupStandings(matchesArray, predictions, teamsArray);

        // Calculamos puntos totales por participante
        const pointsByUser = {};
        predictions.forEach(pred => {
          const res = resultsArray.find(r => r.matchId === pred.matchId);
          let pts = 0;
          if (res && res.homeGoals !== null && res.awayGoals !== null) {
            const diffRes = res.homeGoals - res.awayGoals;
            const diffPred = pred.predHome - pred.predAway;
            if (pred.predHome === res.homeGoals && pred.predAway === res.awayGoals) {
              pts = 5;
            } else if ((diffRes === 0 && diffPred === 0) || (diffRes > 0 && diffPred > 0) || (diffRes < 0 && diffPred < 0)) {
              pts = 3;
            }
          }
          pointsByUser[pred.userId] = (pointsByUser[pred.userId] || 0) + pts;
        });

        // A√±adimos puntos de clasificaci√≥n de grupos
        Object.keys(groupStandings).forEach(uid=>{
          const userGroups=groupStandings[uid];
          if(!userGroups) return;
          Object.keys(userGroups).forEach(g=>{
            if(isGroupComplete(realGroupStandings[g])){
              const pts=calcGroupPoints(userGroups[g], realGroupStandings[g]);
              pointsByUser[uid]=(pointsByUser[uid]||0)+pts;
            }
          });
        });

        leaderboard = Object.entries(pointsByUser).map(([userId, pts]) => {
          const p = participants.find(pr => pr.userId === userId);
          return { userId, displayName: p ? p.displayName : userId, points: pts };
        }).sort((a, b) => b.points - a.points);

        renderLeaderboard();
        dataLoaded=true;
        if(pendingParticipant!==null){
          displayParticipant(pendingParticipant);
          pendingParticipant=null;
        }

        populateSelect();
        // Valor recordado
        const savedParticipant = localStorage.getItem('lastParticipant') || '';
        if(participantSelect.querySelector(`option[value="${savedParticipant}"]`)){
          participantSelect.value = savedParticipant;
        }
        participantSelect.addEventListener('change', () => {
          localStorage.setItem('lastParticipant', participantSelect.value);
          // Forzar que la pr√≥xima carga abra la pesta√±a de Predicciones
          localStorage.setItem('lastTab','pred');
          // Soft reload
          location.reload();
        });

        // Seleccionar pesta√±a guardada
        const savedTab = localStorage.getItem('lastTab') || 'clasif';
        showTab(savedTab);

        // Configurar vista inicial de fase de grupos (por fecha / por grupo)
        const savedView = localStorage.getItem('groupPredView') || 'date';
        setGroupPredView(savedView);
      } catch (err) {
        console.error('Error cargando datos:', err);
        alert('Hubo un problema cargando los datos. Revisa la consola para m√°s detalles.');
      }
    }

    function populateSelect() {
      // Opci√≥n por defecto vac√≠a
      const defaultOpt=document.createElement('option');
      defaultOpt.value='';
      defaultOpt.textContent='Select a participant...';
      participantSelect.appendChild(defaultOpt);
      // Resto de participantes en orden alfab√©tico
      [...participants].sort((a,b)=> a.displayName.localeCompare(b.displayName,'es',{sensitivity:'base'})).forEach(p => {
        const option = document.createElement('option');
        option.value = p.userId;
        option.textContent = p.displayName;
        participantSelect.appendChild(option);
      });
    }

    function createStandingTable(data) {
        const table = document.createElement('table');
        table.classList.add('group-table');
        
        const thead = document.createElement('thead');
        thead.innerHTML = '<tr><th>Pos</th><th>Team</th><th>MP</th><th>Pts</th><th>GF</th><th>GA</th><th>GD</th></tr>';
        table.appendChild(thead);
        
        const tbody = document.createElement('tbody');
        if (data) {
            data.forEach(team => {
                const tr = document.createElement('tr');
                const badgeImg = teamIdToBadge[team.teamId] ? `<img src="${teamIdToBadge[team.teamId]}" class="team-badge" alt="${team.teamName} badge"/>` : '';
                tr.innerHTML = `<td><span class="position-badge pos-${team.position}">${team.position}</span></td><td class="team-name">${badgeImg}${team.teamName}</td><td>${team.matchesPlayed ?? '-'}</td><td class="points-cell">${team.points}</td><td>${team.goalsFor}</td><td>${team.goalsAgainst}</td><td class="goal-diff ${team.goalDifference > 0 ? 'positive' : team.goalDifference < 0 ? 'negative' : ''}">${team.goalDifference > 0 ? '+' : ''}${team.goalDifference}</td>`;
                tbody.appendChild(tr);
            });
        }
        table.appendChild(tbody);
        return table;
    }

    function displayParticipant(userId) {
      const snippetDiv=document.getElementById('leaderSnippet');
      // Referencias a headings h3 (Grupo y KO)
      const groupSection = document.querySelector('.predictions-section:first-of-type');
      const koSection = document.querySelector('.predictions-section:last-of-type');

      const predSections=document.querySelectorAll('.predictions-section');
      const viewSwitchEl=document.getElementById('groupStageViewSwitch');

      if(!userId){
        // Limpiar y ocultar todo
        groupPredictionsBody.innerHTML='';
        koPredictionsBody.innerHTML='';
        standingsContainer.innerHTML='';
        groupPredictionsTable.style.display='none';
        koPredictionsTable.style.display='none';
        standingsSection.style.display='none';
        if(groupSection) groupSection.style.display='none';
        if(koSection) koSection.style.display='none';
        snippetDiv.innerHTML='';
        if(predTitle){ predTitle.textContent=''; }
        predSections.forEach(sec=> sec.style.display='none');
        if(viewSwitchEl) viewSwitchEl.style.display='none';
        return;
      }

      // Asegurar que elementos est√©n visibles al seleccionar participante
      groupPredictionsTable.style.display='';
      koPredictionsTable.style.display='';
      if(groupSection) groupSection.style.display='';
      if(koSection) koSection.style.display='';
      standingsSection.style.display='block';
      if(viewSwitchEl) viewSwitchEl.style.display='flex';
      
      // Obtener clasificaci√≥n de grupos pronosticada y exponerla para la fase KO
      const userStandings = groupStandings[userId];
      currentPredStandings = userStandings || {};

      // Construimos snippet prev-actual-next
      snippetDiv.innerHTML='';
      if(leaderboard.length && participants.find(p=>p.userId===userId)){
          const idx=leaderboard.findIndex(e=>e.userId===userId);
          const lines=[];
          const makeLine=(entry, bold=false)=>{
              const text=`${entry.rank}¬∫ ${entry.displayName} | ${entry.points} pts`;
              return bold?`<div class="snippet-line current">${text}</div>`:`<div class="snippet-line">${text}</div>`;
          };
          leaderboard.forEach((e,i)=>{ e.rank=i+1; });
          if(idx>1){ lines.push(makeLine(leaderboard[idx-2])); }
          if(idx>0){ lines.push(makeLine(leaderboard[idx-1])); }
          lines.push(makeLine(leaderboard[idx], true));
          if(idx<leaderboard.length-1){ lines.push(makeLine(leaderboard[idx+1])); }
          if(idx<leaderboard.length-2){ lines.push(makeLine(leaderboard[idx+2])); }
          snippetDiv.innerHTML=lines.join('');
      }

      // 1. Mostramos predicciones de partidos
      const userPreds = predictions.filter(p => p.userId === userId);
      let groupPreds=[];
      let koPreds=[];
      groupPredictionsBody.innerHTML = '';
      koPredictionsBody.innerHTML = '';
      const isPredTabActive = btnPred.classList.contains('tab-active');

      if (userPreds.length > 0) {
        // Ordenamos las predicciones por fecha de partido
        userPreds.sort((a, b) => {
            const dateA = new Date(matchesById[a.matchId]?.dateTime || 0);
            const dateB = new Date(matchesById[b.matchId]?.dateTime || 0);
            return dateA - dateB;
        });

        // Split predictions
        groupPreds = userPreds.filter(p => matchesById[p.matchId]?.phase === 'group');
        koPreds = userPreds.filter(p => matchesById[p.matchId] && matchesById[p.matchId].phase !== 'group');

        // Render group predictions seg√∫n la vista elegida
        if (groupPreds.length>0){
          if(groupPredView==='date'){
            renderPredTable(groupPreds, groupPredictionsBody,false);
          } else {
            renderPredTableGroup(groupPreds, groupPredictionsBody);
          }
        }

        // Render KO predictions SIEMPRE con estilo "By Date" (renderPredTable con isKO=true)
        if(koPreds.length>0){
           renderPredTable(koPreds, koPredictionsBody, true);
           if(koSection) koSection.style.display='';
        } else {
           koPredictionsBody.innerHTML='';
           if(koSection) koSection.style.display='none';
        }

        if(isPredTabActive){
         if(groupPreds.length>0 || koPreds.length>0){ predTab.style.display='block'; } else { predTab.style.display='none'; }
        }
      } else {
        // Si no hay predicciones pero s√≠ usuario, dejamos tablas vac√≠as
        groupPredictionsBody.innerHTML='';
        koPredictionsBody.innerHTML='';
      }
      
      // 2. Mostramos clasificaciones de grupos (predicci√≥n vs real)
      standingsContainer.innerHTML = '';
      const participant = participants.find(p => p.userId === userId);
      const userName = participant ? participant.displayName : userId;

      if (userStandings && Object.keys(realGroupStandings).length > 0) {
        Object.keys(userStandings).sort().forEach(groupKey => {
            const groupCard = document.createElement('div');
            groupCard.className = 'group-card';
            
            // Wrapper de encabezado vertical
            const headerWrap=document.createElement('div');
            headerWrap.className='group-header';

            // Fila superior (t√≠tulo + badge)
            const headerTop=document.createElement('div');
            headerTop.className='header-top';

            const groupTitle=document.createElement('h3');
            groupTitle.className='group-title';
            groupTitle.textContent=`Group ${groupKey}`;
            // Flecha colapsable
            const arrowGrp=document.createElement('span');
            arrowGrp.className='collapse-arrow';
            arrowGrp.textContent='‚ñº';
            headerTop.classList.add('collapsible-header');
            headerTop.appendChild(arrowGrp);
            headerTop.appendChild(groupTitle);

            headerWrap.appendChild(headerTop);
            // Row con badges de los equipos del grupo
            const badgesRow=document.createElement('div');
            badgesRow.className='group-badges';
            const teamsInGroup=realGroupStandings[groupKey] || Object.values(teamIdToName).filter((_,tid)=> teamsArray.find(t=>t.teamId===tid && t.group===groupKey));
            if(teamsInGroup){
              (Array.isArray(teamsInGroup)?teamsInGroup:[]).forEach(t=>{
                const id=t.teamId||t;
                if(teamIdToBadge[id]){
                  const img=document.createElement('img');
                  img.src=teamIdToBadge[id];
                  img.alt=t.teamName||teamIdToName[id]||id;
                  img.className='team-badge';
                  badgesRow.appendChild(img);
                }
              });
            }
            badgesRow.style.marginTop='8px';
            headerWrap.appendChild(badgesRow);

            groupCard.appendChild(headerWrap);

            const tablesContainer = document.createElement('div');
            tablesContainer.className = 'group-tables';

            // Contenedor de dos columnas para Predicci√≥n y Actual
            const twoWrap=document.createElement('div');
            twoWrap.className='tables-wrap';

            // Columna de Predicci√≥n
            const predictedDiv = document.createElement('div');
            predictedDiv.className = 'table-column';
            const predictedTitle = document.createElement('h4');
            predictedTitle.className = 'table-subtitle';
            predictedTitle.textContent = `Prediction (${userName})`;
            predictedDiv.appendChild(predictedTitle);
            predictedDiv.appendChild(createStandingTable(userStandings[groupKey]));
            twoWrap.appendChild(predictedDiv);

            // Columna Real
            const realDiv = document.createElement('div');
            realDiv.className = 'table-column';
            const realTitle = document.createElement('h4');
            realTitle.className = 'table-subtitle';
            realTitle.textContent = 'Actual';
            realDiv.appendChild(realTitle);
            realDiv.appendChild(createStandingTable(realGroupStandings[groupKey]));
            twoWrap.appendChild(realDiv);

            /* Badge de puntos en el header */
            const badge=document.createElement('span');
            badge.className='points-badge';
            let ptsCalc=null;
            if(isGroupComplete(realGroupStandings[groupKey])){
              ptsCalc=calcGroupPoints(userStandings[groupKey], realGroupStandings[groupKey]);
              badge.textContent=`${ptsCalc} pts`;
            } else {
              badge.textContent='-';
            }
            badge.style.marginLeft='8px';
            headerTop.appendChild(badge);

            // Descripci√≥n debajo y alineada derecha
            const ptsDesc=document.createElement('div');
            ptsDesc.className='points-description';
            if(isGroupComplete(realGroupStandings[groupKey])){
              let reason='';
              switch(ptsCalc){
                case 7: reason='Perfect order prediction';break;
                case 5: reason='Both qualifiers correct';break;
                case 2: reason='One qualifier correct';break;
                default: reason='No correct predictions';
              }
              ptsDesc.textContent=reason;
            } else {
              ptsDesc.textContent='Group not finished';
            }

            // ----- NUEVO: fila badges + descripci√≥n ---------
            const infoRow=document.createElement('div');
            infoRow.className='group-info-row';
            // badgesRow ya creado antes: lo usamos
            badgesRow.classList.add('badges-inline');
            infoRow.appendChild(badgesRow);
            ptsDesc.style.marginLeft='auto';
            infoRow.appendChild(ptsDesc);
            headerWrap.appendChild(infoRow);

            // Ajustar margen inferior del header
            headerWrap.style.marginBottom='20px';

            // Estructura final: solo las dos tablas
            tablesContainer.appendChild(twoWrap);

            groupCard.appendChild(tablesContainer);
            standingsContainer.appendChild(groupCard);

            // Comportamiento de colapsar/expandir
            headerTop.addEventListener('click',()=>{
              const collapsedNow = tablesContainer.style.display !== 'none'; // true => expanded currently
              if(collapsedNow){
                // will collapse
                tablesContainer.style.display='none';
                badgesRow.style.display='';
                arrowGrp.textContent='‚ñ∂';
                headerWrap.style.marginBottom='0';
              } else {
                // will expand
                tablesContainer.style.display='';
                badgesRow.style.display='none';
                arrowGrp.textContent='‚ñº';
                headerWrap.style.marginBottom='20px';
              }
            });

            // Determinar estado LIVE y completado del grupo
            const groupMatchesAll = Object.values(matchesById).filter(m=> m.phase==='group' && m.group===groupKey);
            const todayStr = new Date().toISOString().split('T')[0];
            const isLiveGroup = groupMatchesAll.some(m=> {
              if(m.dateTime.split('T')[0] !== todayStr) return false;
              const res=resultsById[m.matchId];
              const notPlayed = !(res && res.homeGoals!==null && res.awayGoals!==null);
              return notPlayed; // partido de hoy sin resultado
            });
            const isCompleteGroup = isGroupComplete(realGroupStandings[groupKey]);
            const insertStatusBadge=(imgEl)=>{ groupTitle.insertAdjacentElement('afterend', imgEl); };
            if(isLiveGroup){
              const liveImg=document.createElement('img');
              liveImg.src='live.svg';
              liveImg.alt='Live';
              liveImg.className='badge-icon live-icon';
              insertStatusBadge(liveImg);
            } else if(isCompleteGroup){
              const checkImg=document.createElement('img');
              checkImg.src='check.svg';
              checkImg.alt='Completed';
              checkImg.className='badge-icon';
              insertStatusBadge(checkImg);
            }

            // Estado inicial colapsado/expandido
            const initiallyCollapsed = !(FORCE_OPEN_GROUPS.includes(groupKey)) && isCompleteGroup && !isLiveGroup;
            if(initiallyCollapsed){
              tablesContainer.style.display='none';
              badgesRow.style.display='';
              arrowGrp.textContent='‚ñ∂';
              headerWrap.style.marginBottom='0';
            } else {
              badgesRow.style.display='none';
            }
        });
        predTab.style.display = 'block';
      } else {
        predTab.style.display = 'none';
      }

      // Calcular puntos por secci√≥n
      let groupStagePts=0, koStagePts=0;
      const calcPointsFn=(pred)=>{
        const res=resultsById[pred.matchId];
        if(res && res.homeGoals!==null){
          const diff=res.homeGoals-res.awayGoals;
          const predDiff=pred.predHome-pred.predAway;
          if(pred.predHome===res.homeGoals && pred.predAway===res.awayGoals){return 5;}
          if((diff===0 && predDiff===0)||(diff>0 && predDiff>0)||(diff<0 && predDiff<0)){return 3;}
        }
        return 0;
      };
      groupPreds.forEach(p=>{ groupStagePts+=calcPointsFn(p); });
      koPreds.forEach(p=>{ koStagePts+=calcPointsFn(p); });
      // Clasificaci√≥n puntos
      let classifPts=0;
      if(userStandings){
        Object.keys(userStandings).forEach(g=>{
          if(isGroupComplete(realGroupStandings[g])){
            classifPts+=calcGroupPoints(userStandings[g], realGroupStandings[g]);
          }
        });
      }
      // Actualizar spans con l√≥gica especial para KO todav√≠a no iniciado
      const setGroupTotal = (val)=>{
        const el=document.getElementById('groupPredTotal');
        if(el){ el.textContent=`${val} pts`; }
      };
      const setKOTotal = (val)=>{
        const el=document.getElementById('koPredTotal');
        if(!el) return;
        if(val===0){
          // Comprobar si hay alg√∫n partido KO con resultado registrado
          const anyKOPlayed = Object.values(matchesById).some(m=> m.phase!=='group' && resultsById[m.matchId] && resultsById[m.matchId].homeGoals!==null && resultsById[m.matchId].awayGoals!==null);
          el.textContent = anyKOPlayed ? '0 pts' : '-';
        } else {
          el.textContent = `${val} pts`;
        }
      };
      const setClassifTotal = (val)=>{
        const el=document.getElementById('classifTotal');
        if(el){ el.textContent=`${val} pts`; }
      };

      setGroupTotal(groupStagePts);
      setKOTotal(koStagePts);
      setClassifTotal(classifPts);
      // Actualizar iconos LIVE en los headers seg√∫n contenido renderizado
      refreshHeaderLiveIcons();

      /* ---------------- Leader Stats ---------------- */
      const statsEl=document.getElementById('leaderStats');
      if(statsEl){
        // Aciertos exactos y signo
        let exact=0, sign=0, played=0, totalPtsPlayed=0;
        const calcPtsMatch=(pred)=>{
          const res=resultsById[pred.matchId];
          if(res && res.homeGoals!==null){
            const diff=res.homeGoals-res.awayGoals;
            const predDiff=pred.predHome-pred.predAway;
            if(pred.predHome===res.homeGoals && pred.predAway===res.awayGoals) return 5;
            if((diff===0 && predDiff===0)||(diff>0 && predDiff>0)||(diff<0 && predDiff<0)) return 3;
          }
          return 0;
        };
        userPreds.forEach(pred=>{
          const res=resultsById[pred.matchId];
          if(res && res.homeGoals!==null){
            played++;
            const pts=calcPtsMatch(pred);
            totalPtsPlayed+=pts;
            if(pts===5) exact++; else if(pts===3) sign++;
          }
        });
        const exactPct = played? ((exact/played)*100).toFixed(1):'0';
        const signPct = played? ((sign/played)*100).toFixed(1):'0';
        const avgPts = played? (totalPtsPlayed/played).toFixed(2):'0';

        // Grupos puntos
        let perfect=0, semi=0, oneQual=0, groupsCompleted=0;
        Object.keys(realGroupStandings).forEach(g=>{
          if(isGroupComplete(realGroupStandings[g])){
            groupsCompleted++;
            const pts=calcGroupPoints((userStandings||{})[g], realGroupStandings[g]);
            if(pts===7) perfect++; else if(pts===5) semi++; else if(pts===2) oneQual++; 
          }
        });
        const grpPct=(val)=> groupsCompleted? ((val/groupsCompleted)*100).toFixed(1):'0';

        // Puntos m√°ximos posibles
        const currentTotal = leaderboard.find(e=>e.userId===userId)?.points || 0;
        const remainingMatches = userPreds.filter(p=>{
          const res=resultsById[p.matchId];
          return !(res && res.homeGoals!==null);
        }).length;
        const incompleteGroups = 8 - groupsCompleted;
        const maxPotential = currentTotal + remainingMatches*5 + incompleteGroups*7;

        const makeCard=(label,value)=>`<div class=\"stat-card\"><span class=\"stat-value\">${value}</span><span class=\"stat-label\">${label}</span></div>`;
        statsEl.innerHTML=`
          <div class=\"stat-set\">
            <div class=\"stat-set-title\">Matches Stats.</div>
            <div class=\"stat-group\">
              ${makeCard('Exact scores', `${exact} ‚Ä¢ ${exactPct}%`)}
              ${makeCard('Outcome hits', `${sign} ‚Ä¢ ${signPct}%`)}
              ${makeCard('pts / match', `${avgPts}`)}
            </div>
          </div>
          <div class=\"stat-set\">
            <div class=\"stat-set-title\">Groups Stats.</div>
            <div class=\"stat-group\">
              ${makeCard('Perfect', `${perfect} ‚Ä¢ ${grpPct(perfect)}%`)}
              ${makeCard('Semi-perfect', `${semi} ‚Ä¢ ${grpPct(semi)}%`)}
              ${makeCard('1 qualifier', `${oneQual} ‚Ä¢ ${grpPct(oneQual)}%`)}
            </div>
          </div>
        `;
      }
    }

    function renderPredTable(predArray, tbody, isKO){
        const todayStr = new Date().toISOString().split('T')[0];
        tbody.innerHTML='';
        // Sort predictions by date ascending
        predArray.sort((a, b) => new Date(matchesById[a.matchId]?.dateTime) - new Date(matchesById[b.matchId]?.dateTime));

        // Agrupamos por d√≠a (YYYY-MM-DD)
        const groups = {};
        predArray.forEach(p=>{
            const dKey = matchesById[p.matchId]?.dateTime.split('T')[0];
            if(!groups[dKey]) groups[dKey]=[];
            groups[dKey].push(p);
        });

        const dateKeys = Object.keys(groups).sort();

        // Determinar el primer d√≠a con al menos un partido sin resultado (d√≠a "LIVE")
        let ongoingDayKey = null;

        const isGroupStageComplete = !Object.values(matchesById).some(m=> m.phase==='group' && !(resultsById[m.matchId] && resultsById[m.matchId].homeGoals!==null && resultsById[m.matchId].awayGoals!==null));

        if(!isKO){
          // Fase de grupos: siempre aplicamos l√≥gica LIVE
          for(const dk of dateKeys){
            const incomplete = groups[dk].some(pred=>{
              const res = resultsById[pred.matchId];
              return !(res && res.homeGoals!==null && res.awayGoals!==null);
            });
            if(incomplete){ ongoingDayKey = dk; break; }
          }
        } else if(isGroupStageComplete){
          // Solo mostrar LIVE en KO si todos los grupos terminaron
          for(const dk of dateKeys){
            const incomplete = groups[dk].some(pred=>{
              const res = resultsById[pred.matchId];
              return !(res && res.homeGoals!==null && res.awayGoals!==null);
            });
            if(incomplete){ ongoingDayKey = dk; break; }
          }
        }

        // D√≠a inmediatamente anterior al LIVE (si existe)
        let prevDayKey = null;
        if(ongoingDayKey){
          const idx=dateKeys.indexOf(ongoingDayKey);
          if(idx>0) prevDayKey=dateKeys[idx-1];
        }

        // Funci√≥n para calcular puntos por predicci√≥n
        const calcPoints = (pred)=>{
            const res=resultsById[pred.matchId];
            if(res && res.homeGoals!==null){
                const diff=res.homeGoals-res.awayGoals;
                const predDiff=pred.predHome-pred.predAway;
                if(pred.predHome===res.homeGoals && pred.predAway===res.awayGoals){return 5;}
                if((diff===0 && predDiff===0)||(diff>0 && predDiff>0)||(diff<0 && predDiff<0)){return 3;}
            }
            return 0;
        };

        const dayPointsMap = {};
        dateKeys.forEach(k=>{
            dayPointsMap[k]=groups[k].reduce((sum,p)=> sum+calcPoints(p),0);
        });

        // NUEVO: determinar d√≠as a mostrar abiertos (√∫ltimo d√≠a completo + pr√≥ximos 24h)
        const upcomingDayKeys=[];
        const nowMs=Date.now();
        const liveWindow=nowMs+24*60*60*1000;
        const considerLive = (!isKO) || isGroupStageComplete; // En KO solo aplica cuando ya termin√≥ la fase de grupos
        if(considerLive){
          dateKeys.forEach(dk=>{
            const hasUpcoming = groups[dk].some(p=>{
              const matchInfo=matchesById[p.matchId];
              const t=new Date(matchInfo.dateTime).getTime();
              return t>=nowMs && t<=liveWindow;
            });
            if(hasUpcoming){ upcomingDayKeys.push(dk); }
          });
        }

        let lastCompleteDayKey=null;
        for(let i=dateKeys.length-1;i>=0;i--){
          const dk=dateKeys[i];
          const allPlayed=groups[dk].every(p=>{
            const res=resultsById[p.matchId];
            return res && res.homeGoals!==null && res.awayGoals!==null;
          });
          if(allPlayed){ lastCompleteDayKey=dk; break; }
        }

        dateKeys.forEach(dateKey=>{
            const headerTr=document.createElement('tr');
            headerTr.className='day-header';
            const colSpan=isKO?7:6;
            const formattedDate=formatDateEnglish(new Date(dateKey));
            const isInitiallyOpen = FORCE_OPEN_DAYS.includes(dateKey) || upcomingDayKeys.includes(dateKey) || dateKey===lastCompleteDayKey;
            const arrow=isInitiallyOpen?'‚ñº':'‚ñ∂';
            const pts=dayPointsMap[dateKey];
            // Determinar si al menos un partido de ese d√≠a ya tiene resultado
            const anyPlayed = groups[dateKey].some(pred=>{
                const res=resultsById[pred.matchId];
                return res && res.homeGoals!==null && res.awayGoals!==null;
            });
            const ptsDisplay = anyPlayed ? `${pts} pts` : '-';
            const matchesToday=groups[dateKey];
            const allPlayedDay=matchesToday.every(pred=>{
                const res=resultsById[pred.matchId];
                return res && res.homeGoals!==null && res.awayGoals!==null;
            });
            let liveFlag=false;
            // Regla principal: si hoy y a√∫n quedan partidos sin jugar -> LIVE
            if(dateKey===todayStr){
               liveFlag = !allPlayedDay; // solo si NO est√° completo
            }
            // Si todav√≠a no es LIVE por la regla anterior, comprobamos si hay partidos futuros en <24h sin jugar (l√≥gica anterior)
            if(!liveFlag){
              for(const pred of matchesToday){
                  const info=matchesById[pred.matchId];
                  const t=new Date(info.dateTime).getTime();
                  const res=resultsById[pred.matchId];
                  const played=res && res.homeGoals!==null && res.awayGoals!==null;
                  if(!played && t>=nowMs && t<=liveWindow){ liveFlag=true; break; }
              }
            }

            // Escudos de equipos confirmados (solo KO)
            let dayBadgesHtml='';
            if(isKO){
              const badgeArr=[];
              const pushBadge=(tok)=>{
                // Solo mostramos badge real si el token es ya un teamId con escudo.
                const id = teamIdToBadge[tok]? tok : null;
                let src='badges/unknownTeam.png';
                if(id && teamIdToBadge[id]) src=teamIdToBadge[id];
                badgeArr.push(`<img src="${src}" class="team-badge" alt="team"/>`);
              };
              matchesToday.forEach(pred=>{
                const mi=matchesById[pred.matchId];
                pushBadge(mi.homeTeam);
                pushBadge(mi.awayTeam);
              });
              dayBadgesHtml=badgeArr.join('');
            }

            const liveBadge=liveFlag?'<img src="live.svg" class="badge-icon live-icon" alt="Live"/>':'';
            const completedBadge=(allPlayedDay && new Date(dateKey).getTime()<nowMs)?'<img src="check.svg" class="badge-icon" alt="Completed"/>':'';
            if(isKO){
              headerTr.innerHTML=`<td colspan="${colSpan}"><div class="day-header-content"><span class="arrow">${arrow}</span><span class="date-text">${formattedDate}</span>${liveBadge}${completedBadge}<span class="points-badge">${ptsDisplay}</span></div><div class="phase-badges-row">${dayBadgesHtml}</div></td>`;
              // Ocultar badges si el d√≠a estar√° inicialmente expandido
              if(isInitiallyOpen){
                  const rowBadges=headerTr.querySelector('.phase-badges-row');
                  if(rowBadges) rowBadges.style.display='none';
              }
            } else {
              headerTr.innerHTML=`<td colspan="${colSpan}"><div class="day-header-content"><span class="arrow">${arrow}</span><span class="date-text">${formattedDate}</span>${liveBadge}${completedBadge}<span class="points-badge">${ptsDisplay}</span></div></td>`;
            }
            tbody.appendChild(headerTr);

            // Sub‚Äêheader con nombres de columnas para este d√≠a
            const subHeaderTr=document.createElement('tr');
            subHeaderTr.className='sub-header';
            const subHeaders=isKO?
              ['Time','Round','Pred.','Real','Pred.','Real','Pts']:
              ['Time','Round','Match','Pred.','Real','Pts'];

            subHeaderTr.innerHTML=subHeaders.map((h,idx)=>{
                if(idx===subHeaders.length-1){
                    const inner = anyPlayed ? `${ptsDisplay}` : '-';
                    return `<td class=\"pts-header-cell\"><span class=\"day-total points-badge\" style=\"display:none\">${inner}</span><span class=\"pts-text\">${anyPlayed?'pts':''}</span></td>`;
                }
                return `<td>${h}</td>`;
            }).join('');
            tbody.appendChild(subHeaderTr);

            // rows for this date
            groups[dateKey].forEach(pred=>{
                const matchInfo=matchesById[pred.matchId];
                const date=new Date(matchInfo.dateTime);
                const timePart=date.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',hour12:false});
                const matchDate=`${timePart}`;

                let roundText='-';
                switch(matchInfo.phase){case 'group':roundText=`Group ${matchInfo.group}`;break;case 'ro16':roundText='Round of 16';break;case 'qf':roundText='Quarter-Final';break;case 'sf':roundText='Semi-Final';break;case 'final':roundText='Final';break;default:roundText=matchInfo.phase;}
                // Construir versi√≥n m√≥vil/desktop
                let roundShort=''; let roundExtra='';
                if(matchInfo.phase==='group'){
                  roundShort='Grp.';
                  roundExtra=matchInfo.group; // letra del grupo
                } else {
                  switch(matchInfo.phase){
                    case 'ro16': roundShort='R16'; break;
                    case 'qf': roundShort='QF'; break;
                    case 'sf': roundShort='SF'; break;
                    case 'final': roundShort='F'; break;
                    default: roundShort=matchInfo.phase;
                  }
                  if(isKO){ roundExtra=`(${matchInfo.matchId})`; }
                }

                let roundMobile='';
                if(matchInfo.phase==='group'){
                  roundMobile=`${roundShort}<br/>${roundExtra}`; // Grp. + letra
                } else {
                  roundMobile=`${roundShort}${roundExtra?`<br/>${roundExtra}`:''}`;
                }

                // Construir contenido de escritorio: ronda + salto de l√≠nea + matchId si KO
                let roundDesktopContent=roundText;
                if(matchInfo.phase!=='group' && isKO){
                   roundDesktopContent=`${roundText}<br/><span class=\"round-id\">(${matchInfo.matchId})</span>`;
                 }
                const roundHtml=`<span class=\"round-desktop\">${roundDesktopContent}</span><span class=\"round-mobile\">${roundMobile}</span>`;

                const predScoreHtml = `<span class=\"home-score\">${pred.predHome}</span><span class=\"score-sep\">-</span><span class=\"away-score\">${pred.predAway}</span>`;
                const realScoreHtml = (resultsById[pred.matchId] && resultsById[pred.matchId].homeGoals!==null)
                  ? `<span class=\"home-score\">${resultsById[pred.matchId].homeGoals}</span><span class=\"score-sep\">-</span><span class=\"away-score\">${resultsById[pred.matchId].awayGoals}</span>`
                  : `<span class=\"home-score\">-</span><span class=\"score-sep\">-</span><span class=\"away-score\">-</span>`;
                let points=0;
                const played = (resultsById[pred.matchId] && resultsById[pred.matchId].homeGoals!==null);
                if(played){
                    const diff=resultsById[pred.matchId].homeGoals-resultsById[pred.matchId].awayGoals;
                    const predDiff=pred.predHome-pred.predAway;
                    if(pred.predHome===resultsById[pred.matchId].homeGoals && pred.predAway===resultsById[pred.matchId].awayGoals){points=5;}
                    else if((diff===0 && predDiff===0)||(diff>0 && predDiff>0)||(diff<0 && predDiff<0)){points=3;}
                }

                // Determinar texto y clase para badge de puntos
                let ptsClass='none';
                let ptsText='-';
                if(played){
                  ptsText=points.toString();
                  ptsClass = points>0? 'earned' : 'zero';
                }

                let rowHtml='';
                if(isKO){
                    const resolveUserToken=(tok)=>{
                      if(teamIdToName[tok]) return teamIdToName[tok];
                      if(/^[12][A-H]$/i.test(tok)){
                        const pos=parseInt(tok[0],10);
                        const grp=tok[1].toUpperCase();
                        const arr=currentPredStandings[grp];
                        if(arr){
                          // Buscar por la propiedad "position" para ser agn√≥stico al orden del array
                          const found=arr.find(t=>t.position===pos);
                          if(found) return found.teamName;
                          // Fallback por √≠ndice si no se encuentra
                          if(arr[pos-1]) return arr[pos-1].teamName;
                        }
                      }
                      return tok;
                    };
                    // NUEVO: obtenemos los placeholders originales del displayName
                    const parts = matchInfo.displayName.split(' vs ').map(s => s.trim());
                    let predHomeTok, predAwayTok;
                    if(parts.length === 2){
                      predHomeTok = parts[0];
                      predAwayTok = parts[1];
                    } else {
                      predHomeTok = matchInfo.homeTeam;
                      predAwayTok = matchInfo.awayTeam;
                    }
                    const realTokHome = matchInfo.homeTeam;
                    const realTokAway = matchInfo.awayTeam;
                    const buildSpan=(tok, resolved, isReal=false)=>{
                      let id=getIdFromToken(tok);
                      // Si es columna Real y token es placeholder (1A, 2B, W49...), forzamos unknown
                      if(isReal && (/^[12][A-H]$/i.test(tok) || /^W\d+/i.test(tok))){ id=null; }
                      if(!id && resolved!==tok && !isReal){ id=getIdFromToken(resolved); }
                      let src='';
                      if(id && teamIdToBadge[id]){ src=teamIdToBadge[id]; }
                      else if(isReal){ src='badges/unknownTeam.png'; }
                      const badge=src?`<img src="${src}" class="team-badge" alt="${resolved} badge"/>`:'';
                      const idText=id||tok;
                      return `${badge}<span class="team-id">${idText}</span><span class="team-name-full">${resolved}</span>`; };

                    const predictedSpanHome = buildSpan(predHomeTok, resolveUserToken(predHomeTok));
                    const predictedSpanAway = buildSpan(predAwayTok, resolveUserToken(predAwayTok));
                    const predictedHtml = `<span class=\"home-team\">${predictedSpanHome}</span><span class=\"vs-sep\">vs</span><span class=\"away-team\">${predictedSpanAway}</span>`;

                    const realResolvedHome = resolveTeamToken(realTokHome);
                    const realResolvedAway = resolveTeamToken(realTokAway);
                    const realSpanHome = buildSpan(realTokHome, realResolvedHome, true);
                    const realSpanAway = buildSpan(realTokAway, realResolvedAway, true);
                    const realHtml = `<span class=\"home-team\">${realSpanHome}</span><span class=\"vs-sep\">vs</span><span class=\"away-team\">${realSpanAway}</span>`;
                    rowHtml=`<td class=\"time-cell\">${matchDate}</td><td class=\"round-cell\">${roundHtml}</td><td class=\"match-cell\">${predictedHtml}</td><td class=\"match-cell\">${realHtml}</td><td class=\"score-cell prediction\">${predScoreHtml}</td><td class=\"score-cell result\">${realScoreHtml}</td><td class=\"points-cell\"><span class=\"points-badge ${ptsClass}\">${ptsText}</span></td>`;
                } else {
                    // Fase de grupos
                    const homeId = matchInfo.homeTeam;
                    const awayId = matchInfo.awayTeam;
                    const homeBadge = teamIdToBadge[homeId] ? `<img src="${teamIdToBadge[homeId]}" class="team-badge" alt="${teamIdToName[homeId] || ''} badge"/>` : '';
                    const awayBadge = teamIdToBadge[awayId] ? `<img src="${teamIdToBadge[awayId]}" class="team-badge" alt="${teamIdToName[awayId] || ''} badge"/>` : '';
                    const homeName = teamIdToName[homeId] || matchInfo.displayName.split(' vs ')[0];
                    const awayName = teamIdToName[awayId] || matchInfo.displayName.split(' vs ')[1];
                    const matchCol = `<span class=\"home-team\">${homeBadge}<span class=\"team-id\">${homeId}</span><span class=\"team-name-full\">${homeName}</span></span><span class=\"vs-sep\">vs</span><span class=\"away-team\">${awayBadge}<span class=\"team-id\">${awayId}</span><span class=\"team-name-full\">${awayName}</span></span>`;
                    rowHtml=`<td class=\"time-cell\">${matchDate}</td><td class=\"round-cell\">${roundHtml}</td><td class=\"match-cell\">${matchCol}</td><td class=\"score-cell prediction\">${predScoreHtml}</td><td class=\"score-cell result\">${realScoreHtml}</td><td class=\"points-cell\"><span class=\"points-badge ${ptsClass}\">${ptsText}</span></td>`;
                }
                const tr=document.createElement('tr');
                tr.className=`match-row row-${dateKey}`;
                tr.innerHTML=rowHtml;
                tbody.appendChild(tr);
            });

            // collapsible behaviour
            const toggleRows=()=>{
                let next=headerTr.nextElementSibling;
                while(next && !next.classList.contains('day-header')){
                    next.style.display = (next.style.display==='none')?'':'none';
                    next=next.nextElementSibling;
                }
            };
            headerTr.addEventListener('click',()=>{
                toggleRows();
                const arrowSpan=headerTr.querySelector('.arrow');
                if(arrowSpan){
                    arrowSpan.textContent = (arrowSpan.textContent==='‚ñº')?'‚ñ∂':'‚ñº';
                }
                const badgesRowEl=headerTr.querySelector('.phase-badges-row');
                if(badgesRowEl){
                   const expanded = arrowSpan.textContent==='‚ñº';
                   badgesRowEl.style.display = expanded? 'none' : 'flex';
                }
                const badgeHeader=headerTr.querySelector('.points-badge');
                const badgeSub=subHeaderTr.querySelector('.day-total');
                const ptsText=subHeaderTr.querySelector('.pts-text');
                const isExpanded = arrowSpan.textContent==='‚ñº';
                if(isExpanded){
                    badgeHeader.style.visibility='hidden';
                    badgeSub.style.display='inline-block';
                    if(ptsText) ptsText.style.display='none';
                } else {
                    badgeHeader.style.visibility='visible';
                    badgeSub.style.display='none';
                    if(ptsText) ptsText.style.display='inline';
                }
            });

            // Inicialmente colapsamos si no debe estar abierto
            if(!isInitiallyOpen){
                toggleRows();
                const arrowSpan=headerTr.querySelector('.arrow');
                if(arrowSpan){ arrowSpan.textContent='‚ñ∂'; }
            } else {
                // Mostrar badge en subheader, ocultar en header
                const badgeHeader=headerTr.querySelector('.points-badge');
                const badgeSub=subHeaderTr.querySelector('.day-total');
                const ptsText=subHeaderTr.querySelector('.pts-text');
                badgeHeader.style.visibility='hidden';
                badgeSub.style.display='inline-block';
                if(ptsText) ptsText.style.display='none';
            }
        });
    }

    function resolveTeamToken(token) {
      if (teamIdToName[token]) return teamIdToName[token];
      if (/^[12][A-H]$/i.test(token)) {
        const pos = parseInt(token[0], 10);
        const group = token[1].toUpperCase();
        const standingsArr = realGroupStandings[group];
        const groupFinished = standingsArr && standingsArr.every(t => t.matchesPlayed === 3);
        if (groupFinished && standingsArr[pos - 1]) {
          return standingsArr[pos - 1].teamName;
        }
      }
      return token; // Mantener placeholder (Wxx, 1A, etc.)
    }

    function getRealKOName(match) {
      // NUEVO: resolvemos a partir de displayName para mantener placeholders cuando proceda
      const parts = match.displayName.split(' vs ').map(s => s.trim());
      if(parts.length === 2){
        const home = resolveTeamToken(parts[0]);
        const away = resolveTeamToken(parts[1]);
        return `${home} vs ${away}`;
      }
      const home = resolveTeamToken(match.homeTeam);
      const away = resolveTeamToken(match.awayTeam);
      return `${home} vs ${away}`;
    }

    function showTab(tab){
        if(tab==='pred'){
            predTab.style.display='block';
            clasifTab.style.display='none';
            standingsSection.style.display='block';
            predControls.style.display='block';
            btnPred.classList.add('tab-active');
            btnClasif.classList.remove('tab-active');
            if(dataLoaded){
              displayParticipant(participantSelect.value);
            } else {
              pendingParticipant=participantSelect.value;
            }
            predTitle.textContent='';
        } else {
            predTab.style.display='none';
            clasifTab.style.display='block';
            standingsSection.style.display='none';
            predControls.style.display='none';
            btnClasif.classList.add('tab-active');
            btnPred.classList.remove('tab-active');
            predTitle.textContent='';
        }
    }

    btnPred.addEventListener('click',()=>{ localStorage.setItem('lastTab','pred'); showTab('pred'); });
    btnClasif.addEventListener('click',()=>{ localStorage.setItem('lastTab','clasif'); showTab('clasif'); });

    function renderLeaderboard(){
        const tbody=document.querySelector('#leaderboardTable tbody');
        tbody.innerHTML='';

        // Determinar d√≠a ongoing y el inmediatamente anterior con todos los partidos finalizados
        const allDateMap={};
        Object.values(matchesById).forEach(m=>{
          const dKey=m.dateTime.split('T')[0];
          if(!allDateMap[dKey]) allDateMap[dKey]=[];
          allDateMap[dKey].push(m);
        });
        const allDateKeys=Object.keys(allDateMap).sort();
        let ongoingKey=null;
        for(const dk of allDateKeys){
          const unfinished=allDateMap[dk].some(m=>{
            const res=resultsById[m.matchId];
            return !(res && res.homeGoals!==null && res.awayGoals!==null);
          });
          if(unfinished){ ongoingKey=dk; break; }
        }
        const prevDayKey=allDateKeys[allDateKeys.indexOf(ongoingKey)-1] || null;

        // Actualizar cabecera con fecha
        const prevHeader=document.getElementById('prevDayHeader');
        if(prevHeader){
          if(prevDayKey){
            const dateObj=new Date(prevDayKey);
            const dateStr=formatDateEnglish(dateObj);
            prevHeader.textContent=`PREV. DAY`;
          } else {
            prevHeader.textContent='Points';
          }
        }

        // Calcular puntos obtenidos por usuario en prevDayKey
        const pointsYesterday={};
        if(prevDayKey){
          const calcPts=(pred)=>{
            const res=resultsById[pred.matchId];
            if(res && res.homeGoals!==null){
              const diff=res.homeGoals-res.awayGoals;
              const predDiff=pred.predHome-pred.predAway;
              if(pred.predHome===res.homeGoals && pred.predAway===res.awayGoals) return 5;
              if((diff===0 && predDiff===0)||(diff>0 && predDiff>0)||(diff<0 && predDiff<0)) return 3;
            }
            return 0;
          };
          predictions.forEach(pred=>{
            const match=matchesById[pred.matchId];
            if(match && match.dateTime.split('T')[0]===prevDayKey){
              pointsYesterday[pred.userId]=(pointsYesterday[pred.userId]||0)+calcPts(pred);
            }
          });
          // A√±adir puntos de grupos finalizados ese d√≠a
          Object.keys(realGroupStandings).forEach(g=>{
            const groupMatches=Object.values(matchesById).filter(m=>m.phase==='group' && m.group===g);
            const lastDate=groupMatches.reduce((max,m)=> m.dateTime>max?m.dateTime:max,'');
            if(lastDate.split('T')[0]===prevDayKey){
              participants.forEach(p=>{
                const uid=p.userId;
                const userGs=groupStandings[uid];
                if(userGs && userGs[g]){
                  const pts=calcGroupPoints(userGs[g], realGroupStandings[g]);
                  pointsYesterday[uid]=(pointsYesterday[uid]||0)+pts;
                }
              });
            }
          });
        }

        // Construir ranking del d√≠a anterior
        const prevTotals=leaderboard.map(e=>({userId:e.userId, pts:e.points-(pointsYesterday[e.userId]||0)}));
        prevTotals.sort((a,b)=> b.pts - a.pts);
        const prevRankMap={};
        let prevRankNum=1, lastPrevPts=null;
        prevTotals.forEach((item,idx)=>{
          if(idx>0 && item.pts!==lastPrevPts){ prevRankNum=idx+1; }
          prevRankMap[item.userId]=prevRankNum;
          lastPrevPts=item.pts;
        });

        // ---------- C√ÅLCULO HIST√ìRICO PARA PROGRESS (antes de crear filas) ----------
        const rankHistoryByUser={};
        const cumulativePoints={};
        participants.forEach(p=>{ cumulativePoints[p.userId]=0; rankHistoryByUser[p.userId]=[]; });

        const progressDates = ongoingKey ? allDateKeys.filter(dk=> dk<ongoingKey) : allDateKeys;

        const calcPtsMatch=(pred)=>{
          const res=resultsById[pred.matchId];
          if(res && res.homeGoals!==null){
            const diff=res.homeGoals-res.awayGoals;
            const predDiff=pred.predHome-pred.predAway;
            if(pred.predHome===res.homeGoals && pred.predAway===res.awayGoals) return 5;
            if((diff===0 && predDiff===0)||(diff>0 && predDiff>0)||(diff<0 && predDiff<0)) return 3;
          }
          return 0;
        };

        progressDates.forEach(dk=>{
          predictions.forEach(pred=>{
            const match=matchesById[pred.matchId];
            if(match && match.dateTime.split('T')[0]===dk){
              const pts=calcPtsMatch(pred);
              if(pts>0){ cumulativePoints[pred.userId]=(cumulativePoints[pred.userId]||0)+pts; }
            }
          });
          // puntos group clasif
          Object.keys(realGroupStandings).forEach(g=>{
            const real=realGroupStandings[g];
            if(!isGroupComplete(real)) return;
            const groupMatches=Object.values(matchesById).filter(m=> m.phase==='group' && m.group===g);
            const lastDate=groupMatches.reduce((max,m)=> m.dateTime>max?m.dateTime:max,'');
            if(lastDate.split('T')[0]!==dk) return;
            participants.forEach(p=>{
              const uid=p.userId;
              const userGs=groupStandings[uid];
              if(userGs && userGs[g]){
                const pts=calcGroupPoints(userGs[g], real);
                cumulativePoints[uid]=(cumulativePoints[uid]||0)+pts;
              }
            });
          });
          // ranking del d√≠a
          const sorted=Object.entries(cumulativePoints).sort((a,b)=> b[1]-a[1]);
          let rank=1, lastPts=null;
          sorted.forEach(([uid,pts],idx)=>{
            if(idx>0 && pts!==lastPts){ rank=idx+1; }
            rankHistoryByUser[uid].push(rank);
            lastPts=pts;
          });
        });

        const buildSparkline=(arr,maxRank)=>{
          if(!arr || arr.length===0) return '';
          const width=60, height=24;
          if(arr.length===1){
            const y=(arr[0]-1)/(maxRank-1)*height;
            return `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" preserveAspectRatio="none"><circle cx="${width}" cy="${y}" r="2" fill="#0969da" /></svg>`;
          }
          const step=width/(arr.length-1);
          const points=arr.map((r,i)=>{
            const x=i*step;
            const y=(r-1)/(maxRank-1)*height;
            return `${x},${y}`;
          }).join(' ');
          return `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" preserveAspectRatio="none"><polyline fill="none" stroke="#0969da" stroke-width="2" points="${points}" /></svg>`;
        };

        leaderboard.forEach((entry,idx)=>{
            const tr=document.createElement('tr');
            tr.className = 'leaderboard-row';
            // Empates en puntos -> "=" excepto primer miembro del empate
            let posDisplay = idx+1;
            if(idx>0 && entry.points === leaderboard[idx-1].points){ posDisplay='='; }

            const gained=pointsYesterday[entry.userId]||0;

            // Variaci√≥n de posiciones
            const currentRankNum=(posDisplay==='=')? (function(){
                // buscar rank number of first tied above
                let i=idx;
                while(i>0 && leaderboard[i-1].points===entry.points){ i--; }
                return i+1;
            })(): idx+1;
            const prevRank=prevRankMap[entry.userId]||currentRankNum;
            const diffRank=prevRank-currentRankNum; // positivo si sube

            // Medal icons for top 3
            let rankDisplay = posDisplay;
            if (currentRankNum === 1) rankDisplay = 'ü•á';
            else if (currentRankNum === 2) rankDisplay = 'ü•à';
            else if (currentRankNum === 3) rankDisplay = 'ü•â';
            else if (currentRankNum === 17) rankDisplay = 'üèÆ';
            tr.innerHTML=`
              <td class="rank-cell">
                <div class="rank-content">
                  <span class="rank-number">${rankDisplay}</span>
                  ${diffRank > 0 ? `<span class="rank-change up">‚Üë${diffRank}</span>` : diffRank < 0 ? `<span class="rank-change down">‚Üì${Math.abs(diffRank)}</span>` : ''}
                </div>
              </td>
              <td class="participant-cell">
                <a href="#pred" class="participant-link" data-userid="${entry.userId}">${entry.displayName}</a>
              </td>
              <td class="points-cell">
                <span class="total-points">${entry.points}</span>
              </td>
              <td class="progress-cell">
                ${buildSparkline(rankHistoryByUser[entry.userId], participants.length)}
              </td>
            `;
            tbody.appendChild(tr);
        });

        // Timestamp actualizado
        const updatedEl=document.getElementById('updatedAt');
        let lastDate=null;
        Object.keys(resultsById).forEach(mid=>{
            const res=resultsById[mid];
            if(res.homeGoals!==null && res.awayGoals!==null){
                const match=matchesById[mid];
                if(match){
                    const d=new Date(match.dateTime);
                    if(!lastDate || d>lastDate){ lastDate=d; }
                }
            }
        });
        if(lastDate){
            // Usar la fecha/hora del √∫ltimo partido completo y sumar 3 horas
            const ts=new Date(lastDate.getTime()+2.25*60*60*1000);
            const dateStr=formatDateEnglish(ts);
            const timeStr=ts.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',hour12:false});
            updatedEl.textContent=`Last updated: ${dateStr}, ${timeStr}`;
        }

        /* ---------- Global Stats Top 3 (para las 6 m√©tricas) ---------- */
        const globalStatsEl=document.getElementById('globalStats');
        if(globalStatsEl){
          // Precomputar m√©tricas por usuario
          const metricsByUser = {};
          const calcPtsMatch = (pred) => {
            const res = resultsById[pred.matchId];
            if(res && res.homeGoals!==null){
              const diff = res.homeGoals - res.awayGoals;
              const predDiff = pred.predHome - pred.predAway;
              if(pred.predHome===res.homeGoals && pred.predAway===res.awayGoals) return 5;
              if((diff===0 && predDiff===0) || (diff>0 && predDiff>0) || (diff<0 && predDiff<0)) return 3;
            }
            return 0;
          };

          const completedGroups = Object.keys(realGroupStandings).filter(g=> isGroupComplete(realGroupStandings[g]));

          participants.forEach(p => {
            const uid = p.userId;
            const userPreds = predictions.filter(pr => pr.userId===uid);
            let exact=0, sign=0, played=0, totalPtsPlayed=0;
            userPreds.forEach(pr=>{
              const res = resultsById[pr.matchId];
              if(res && res.homeGoals!==null){
                played++;
                const pts = calcPtsMatch(pr);
                totalPtsPlayed += pts;
                if(pts===5) exact++; else if(pts===3) sign++;
              }
            });
            const avgPts = played? (totalPtsPlayed/played):0;

            let perfect=0, semi=0, oneQual=0;
            completedGroups.forEach(g=>{
              const userGs = groupStandings[uid];
              const pts = userGs && userGs[g] ? calcGroupPoints(userGs[g], realGroupStandings[g]) : 0;
              if(pts===7) perfect++; else if(pts===5) semi++; else if(pts===2) oneQual++;
            });

            metricsByUser[uid] = {displayName:p.displayName || uid, exact, sign, avgPts:parseFloat(avgPts.toFixed(2)), perfect, semi, oneQual};
          });

          const getTop = key => Object.values(metricsByUser).sort((a,b)=> b[key]-a[key]).slice(0,3);

          const metrics = [
            {key:'exact', title:'Exact scores'},
            {key:'sign', title:'Outcome hits'},
            {key:'avgPts', title:'Pts / match'},
            {key:'perfect', title:'Perfect groups'},
            {key:'semi', title:'Semi-perfect'},
            {key:'oneQual', title:'1 qualifier'}
          ];

          const matchesMetrics=['exact','sign','avgPts'];
          const groupsMetrics=['perfect','semi','oneQual'];

          const buildMetricHTML=(m)=>{
            const top=getTop(m.key);
            const itemsHtml=top.map(t=>`<li class=\"top-item\"><span class=\"name\">${t.displayName}</span><span class=\"value\">${t[m.key]}</span></li>`).join('');
            return `<div class=\"stat-set\"><div class=\"stat-set-title\">${m.title}</div><ul class=\"top-list\">${itemsHtml}</ul></div>`;
          };

          const matchesHTML=metrics.filter(m=>matchesMetrics.includes(m.key)).map(buildMetricHTML).join('');
          const groupsHTML=metrics.filter(m=>groupsMetrics.includes(m.key)).map(buildMetricHTML).join('');

          globalStatsEl.innerHTML = `
            <h3 class=\"section-title\">Overall Stats</h3>
            <div class=\"stats-block\">
              <div class=\"stats-block-title\">Matches Stats.</div>
              <div class=\"stats-group\">${matchesHTML}</div>
            </div>
            <div class=\"stats-block\">
              <div class=\"stats-block-title\">Groups Stats.</div>
              <div class=\"stats-group\">${groupsHTML}</div>
            </div>`;
        }
     }

    // Calcula puntos de clasificaci√≥n de grupo seg√∫n reglas
    function calcGroupPoints(predicted, real){
      if(!predicted || !real || predicted.length<4 || real.length<4) return 0;
      const predOrder = predicted.map(t=>t.teamName).join('|');
      const realOrder = real.map(t=>t.teamName).join('|');
      if(predOrder===realOrder){ return 7; }
      const predQual = predicted.slice(0,2).map(t=>t.teamName);
      const realQual = real.slice(0,2).map(t=>t.teamName);
      const matches = predQual.filter(n=>realQual.includes(n)).length;
      if(matches===2) return 5;
      if(matches===1) return 2;
      return 0;
    }

    // Devuelve true si un grupo termin√≥ (3 partidos cada equipo)
    function isGroupComplete(realArr){
      return realArr && realArr.length && realArr.every(t=>t.matchesPlayed===3);
    }

    /** ----------------------------------------------------------
     *  NUEVA FUNCI√ìN: calcular clasificaci√≥n real a partir de resultados
     *  (reglas simplificadas: puntos, diferencia de goles, goles a favor)
     * ---------------------------------------------------------*/
    function computeRealGroupStandings(matchesArr, resultsArr, teamsArr){
      const teamIdToName = Object.fromEntries(teamsArr.map(t=>[t.teamId, t.name]));
      const teamIdToGroup = Object.fromEntries(teamsArr.map(t=>[t.teamId, t.group]));
      const standings = {};
      // Agrupar por equipo -> stats base
      const statsMap = {};
      teamsArr.forEach(t=>{
        statsMap[t.teamId]={
          teamId:t.teamId,
          teamName:teamIdToName[t.teamId],
          points:0, goalsFor:0, goalsAgainst:0, goalDifference:0, matchesPlayed:0
        };
      });
      // Procesar cada resultado de fase de grupos
      matchesArr.forEach(match=>{
        if(match.phase!== 'group') return;
        const res = resultsArr.find(r=> r.matchId===match.matchId);
        if(!res || res.homeGoals===null || res.awayGoals===null) return;
        const homeStats = statsMap[match.homeTeam];
        const awayStats = statsMap[match.awayTeam];
        if(!homeStats || !awayStats) return;
        // Actualizar PJ
        homeStats.matchesPlayed++; awayStats.matchesPlayed++;
        // Goles
        homeStats.goalsFor += res.homeGoals; homeStats.goalsAgainst += res.awayGoals;
        awayStats.goalsFor += res.awayGoals; awayStats.goalsAgainst += res.homeGoals;
        // Puntos
        if(res.homeGoals>res.awayGoals){ homeStats.points+=3; }
        else if(res.homeGoals<res.awayGoals){ awayStats.points+=3; }
        else { homeStats.points+=1; awayStats.points+=1; }
      });
      // Calcular DG y agrupar por grupo
      Object.values(statsMap).forEach(st=>{
        st.goalDifference = st.goalsFor - st.goalsAgainst;
        const grp = teamIdToGroup[st.teamId];
        if(!standings[grp]) standings[grp]=[];
        standings[grp].push(st);
      });
      // Ordenar y a√±adir posici√≥n
      Object.keys(standings).forEach(g=>{
        standings[g].sort((a,b)=>{
          if(b.points!==a.points) return b.points-a.points;
          if(b.goalDifference!==a.goalDifference) return b.goalDifference-a.goalDifference;
          if(b.goalsFor!==a.goalsFor) return b.goalsFor-a.goalsFor;
          return a.teamName.localeCompare(b.teamName);
        });
        standings[g].forEach((t,idx)=> t.position = idx+1);
      });
      return standings;
    }

    /** ----------------------------------------------------------
     *  NUEVO: calcular clasificaci√≥n PRONOSTICADA de cada usuario
     * ---------------------------------------------------------*/
    function computePredictedGroupStandingsForUser(userPredictions, matchesArr, teamsArr) {
      // Filtrar solo los partidos de fase de grupos con predicci√≥n
      const predResults = userPredictions
        .filter(p => {
          const match = matchesArr.find(m => m.matchId === p.matchId);
          return match && match.phase === 'group';
        })
        .map(p => ({
          matchId: p.matchId,
          homeGoals: p.predHome,
          awayGoals: p.predAway
        }));

      return computeRealGroupStandings(matchesArr, predResults, teamsArr);
    }

    function computeAllPredictedGroupStandings(matchesArr, predictionsArr, teamsArr) {
      const byUser = {};
      const predsByUser = {};
      predictionsArr.forEach(p => {
        if (!predsByUser[p.userId]) predsByUser[p.userId] = [];
        predsByUser[p.userId].push(p);
      });
      Object.keys(predsByUser).forEach(uid => {
        byUser[uid] = computePredictedGroupStandingsForUser(predsByUser[uid], matchesArr, teamsArr);
      });
      return byUser;
    }

    // Devuelve fecha en ingl√©s: 25th June
    function formatDateEnglish(date){
      const day=date.getDate();
      const suffix=(day%10===1&&day!==11)?'st':(day%10===2&&day!==12)?'nd':(day%10===3&&day!==13)?'rd':'th';
      const month=date.toLocaleString('en-GB',{month:'long'});
      return `${day}${suffix} ${month}`;
    }

    // Iniciamos la app
    loadData();

    // Eliminado el Service Worker: si hubiera uno previo, lo desregistramos
    if('serviceWorker' in navigator){
      navigator.serviceWorker.getRegistrations().then(regs=>{
        regs.forEach(r=> r.unregister());
      });
    }

    // Delegaci√≥n de clic en links de participantes para navegar a Predicciones
    document.getElementById('leaderboardTable').addEventListener('click',e=>{
      const link=e.target.closest('.participant-link');
      if(link){
        e.preventDefault();
        const uid=link.dataset.userid;
        participantSelect.value=uid;
        localStorage.setItem('lastParticipant',uid);
        showTab('pred');
      }
    });

    // Configurar secciones colapsables
    document.querySelectorAll('.collapsible-header').forEach(header=>{
      const arrow=header.querySelector('.collapse-arrow');
      const content=startContent(header);
      header.addEventListener('click',()=>{
        const isHidden=content.style.display==='none';
        content.style.display=isHidden?'':'none';
        if(arrow){ arrow.textContent=isHidden?'‚ñº':'‚ñ∂'; }
      });
    });

    function startContent(header){
      // el contenido es el siguiente elemento hermano que no sea header
      let el=header.nextElementSibling;
      while(el && el.classList.contains('section-header')){ el=el.nextElementSibling; }
      return el;
    }

    /* Estado inicial desplegado/plegado basado en fecha */
    const collapseHeader=(id, collapsed)=>{
      const hdr=document.getElementById(id);
      if(!hdr) return;
      const arrow=hdr.querySelector('.collapse-arrow');
      const content=startContent(hdr);
      if(collapsed){
        content.style.display='none';
        if(arrow) arrow.textContent='‚ñ∂';
      } else {
        content.style.display='';
        if(arrow) arrow.textContent='‚ñº';
      }
    };

    const now=new Date();
    const switchDate=new Date('2025-06-28T00:00:00+02:00');
    if(now >= switchDate){
      /* Despu√©s del switch: solo KO abierto */
      collapseHeader('groupPredHeader',true);
      collapseHeader('classifHeader',true);
      collapseHeader('koPredHeader',false);
    } /* antes: todo abierto, no hacemos nada */

    // ---------------------------
    // Vista por fecha / por grupo
    // ---------------------------
    function setGroupPredView(view){
      groupPredView = (view==='group')?'group':'date';
      localStorage.setItem('groupPredView', groupPredView);
      const btnDate=document.getElementById('btnViewDate');
      const btnGroup=document.getElementById('btnViewGroup');
      if(btnDate){ btnDate.classList.toggle('active', groupPredView==='date'); }
      if(btnGroup){ btnGroup.classList.toggle('active', groupPredView==='group'); }
      if(dataLoaded && btnPred.classList.contains('tab-active')){
        // Re‚Äêrenderizar solo si la pesta√±a Predictions est√° activa
        displayParticipant(participantSelect.value);
      }
    }

    // Event listeners de los botones
    document.getElementById('btnViewDate').addEventListener('click',()=> setGroupPredView('date'));
    document.getElementById('btnViewGroup').addEventListener('click',()=> setGroupPredView('group'));

    // Renderizar tabla agrupada por grupo
    function renderPredTableGroup(predArray, tbody){
        tbody.innerHTML='';

        // Agrupar por letra de grupo
        const groups = {};
        predArray.forEach(p=>{
            const grp = matchesById[p.matchId]?.group || '-';
            if(!groups[grp]) groups[grp]=[];
            groups[grp].push(p);
        });

        const groupKeys = Object.keys(groups).sort();

        // Funci√≥n para calcular puntos por predicci√≥n (misma l√≥gica que antes)
        const calcPoints = (pred)=>{
            const res=resultsById[pred.matchId];
            if(res && res.homeGoals!==null){
                const diff=res.homeGoals-res.awayGoals;
                const predDiff=pred.predHome-pred.predAway;
                if(pred.predHome===res.homeGoals && pred.predAway===res.awayGoals){return 5;}
                if((diff===0 && predDiff===0)||(diff>0 && predDiff>0)||(diff<0 && predDiff<0)){return 3;}
            }
            return 0;
        };

        // NUEVO: calcular grupos LIVE y √∫ltimo completo
        const isGroupLive = (gKey)=>{
          const matchesAll = Object.values(matchesById).filter(m=> m.phase==='group' && m.group===gKey);
          let rec=0, miss=0;
          matchesAll.forEach(m=>{
            const res=resultsById[m.matchId];
            if(res && res.homeGoals!==null && res.awayGoals!==null){ rec++; } else { miss++; }
          });
          return rec>0 && miss>0;
        };
        const liveGroupKeys = groupKeys.filter(k=> isGroupLive(k));

        groupKeys.forEach((gKey)=>{
            const items = groups[gKey].sort((a,b)=> new Date(matchesById[a.matchId].dateTime) - new Date(matchesById[b.matchId].dateTime));

            const isInitiallyOpen = FORCE_OPEN_GROUPS.includes(gKey) || liveGroupKeys.includes(gKey);
            const arrow = isInitiallyOpen ? '‚ñº' : '‚ñ∂';
            const ptsTotal = items.reduce((sum,p)=> sum+calcPoints(p),0);
            const anyPlayedGroup = items.some(pred=>{
                const res=resultsById[pred.matchId];
                return res && res.homeGoals!==null && res.awayGoals!==null;
            });
            const ptsDisplayGrp = anyPlayedGroup ? `${ptsTotal} pts` : '-';

            const headerTr=document.createElement('tr');
            headerTr.className='day-header';
            const groupMatchesAll = Object.values(matchesById).filter(m=> m.phase==='group' && m.group===gKey);
            const todayStr = new Date().toISOString().split('T')[0];
            const isLiveGroup = groupMatchesAll.some(m=> {
              if(m.dateTime.split('T')[0] !== todayStr) return false;
              const res=resultsById[m.matchId];
              const notPlayed = !(res && res.homeGoals!==null && res.awayGoals!==null);
              return notPlayed; // partido de hoy sin resultado
            });
            const isCompleteGroup = isGroupComplete(realGroupStandings[gKey]);
            const liveBadge = isLiveGroup ? '<img src="live.svg" class="badge-icon live-icon" alt="Live"/>' : '';
            const completedBadge = isCompleteGroup ? '<img src="check.svg" class="badge-icon" alt="Completed"/>' : '';
            headerTr.innerHTML=`<td colspan="6"><div class="day-header-content"><span class="arrow">${arrow}</span><span class="date-text">Group ${gKey}</span>${liveBadge}${completedBadge}<span class="points-badge">${ptsDisplayGrp}</span></div></td>`;
            tbody.appendChild(headerTr);

            const subHeaderTr=document.createElement('tr');
            subHeaderTr.className='sub-header';
            const subHeaders=['Date','Time','Match','Pred.','Real','Pts'];
            subHeaderTr.innerHTML=subHeaders.map((h,idx)=>{
                if(idx===subHeaders.length-1){
                    const inner = anyPlayedGroup ? `${ptsDisplayGrp}` : '-';
                    return `<td class="pts-header-cell"><span class="day-total points-badge" style="display:none">${inner}</span><span class="pts-text">${anyPlayedGroup?'pts':''}</span></td>`;
                }
                return `<td>${h}</td>`;
            }).join('');
            tbody.appendChild(subHeaderTr);

            // Construir filas de partidos
            items.forEach(pred=>{
                const matchInfo=matchesById[pred.matchId];
                const date=new Date(matchInfo.dateTime);
                const timePart=date.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',hour12:false});
                const matchDate=`${timePart}`;

                const dateCell = date.toLocaleString('en-GB',{day:'numeric', month:'long'});

                const predScoreHtml = `<span class="home-score">${pred.predHome}</span><span class="score-sep">-</span><span class="away-score">${pred.predAway}</span>`;
                const res=resultsById[pred.matchId];
                const realScoreHtml = (res && res.homeGoals!==null)
                  ? `<span class="home-score">${res.homeGoals}</span><span class="score-sep">-</span><span class="away-score">${res.awayGoals}</span>`
                  : `<span class="home-score">-</span><span class="score-sep">-</span><span class="away-score">-</span>`;

                // Calcular puntos
                const points=calcPoints(pred);
                let ptsClass='none';
                let ptsText='-';
                const played = res && res.homeGoals!==null;
                if(played){
                    ptsText=points.toString();
                    ptsClass = points>0? 'earned':'zero';
                }

                // Nombre de display
                const homeId = matchInfo.homeTeam;
                const awayId = matchInfo.awayTeam;
                const homeBadge = teamIdToBadge[homeId] ? `<img src="${teamIdToBadge[homeId]}" class="team-badge" alt="${teamIdToName[homeId] || ''} badge"/>` : '';
                const awayBadge = teamIdToBadge[awayId] ? `<img src="${teamIdToBadge[awayId]}" class="team-badge" alt="${teamIdToName[awayId] || ''} badge"/>` : '';
                const homeName = teamIdToName[homeId] || matchInfo.displayName.split(' vs ')[0];
                const awayName = teamIdToName[awayId] || matchInfo.displayName.split(' vs ')[1];
                const matchCol = `<span class=\"home-team\">${homeBadge}<span class=\"team-id\">${homeId}</span><span class=\"team-name-full\">${homeName}</span></span><span class=\"vs-sep\">vs</span><span class=\"away-team\">${awayBadge}<span class=\"team-id\">${awayId}</span><span class=\"team-name-full\">${awayName}</span></span>`;

                const rowHtml=`<td class="round-cell">${dateCell}</td><td class="time-cell">${matchDate}</td><td class="match-cell">${matchCol}</td><td class="score-cell prediction">${predScoreHtml}</td><td class="score-cell result">${realScoreHtml}</td><td class="points-cell"><span class="points-badge ${ptsClass}">${ptsText}</span></td>`;

                const tr=document.createElement('tr');
                tr.className='match-row';
                tr.innerHTML=rowHtml;
                tbody.appendChild(tr);
            });

            // Comportamiento colapsable + traslado de badge
            const toggleRows=()=>{
                let next=headerTr.nextElementSibling;
                while(next && !next.classList.contains('day-header')){
                    next.style.display = (next.style.display==='none')?'':'none';
                    next=next.nextElementSibling;
                }
            };
            const updateBadges=(expanded)=>{
                const badgeHeader=headerTr.querySelector('.points-badge');
                const badgeSub=subHeaderTr.querySelector('.day-total');
                const ptsText=subHeaderTr.querySelector('.pts-text');
                if(expanded){
                    badgeHeader.style.visibility='hidden';
                    badgeSub.style.display='inline-block';
                    if(ptsText) ptsText.style.display='none';
                } else {
                    badgeHeader.style.visibility='visible';
                    badgeSub.style.display='none';
                    if(ptsText) ptsText.style.display='inline';
                }
            };

            // Listener
            headerTr.addEventListener('click',()=>{
                toggleRows();
                const arrowSpan=headerTr.querySelector('.arrow');
                if(arrowSpan){ arrowSpan.textContent = (arrowSpan.textContent==='‚ñº')?'‚ñ∂':'‚ñº'; }
                const expanded = arrowSpan.textContent==='‚ñº';
                updateBadges(expanded);
                const badgesRowEl=headerTr.querySelector('.phase-badges-row');
                if(badgesRowEl){
                   const expanded = arrowSpan.textContent==='‚ñº';
                   badgesRowEl.style.display = expanded? 'none' : 'flex';
                }
                const badgeHeader=headerTr.querySelector('.points-badge');
                const badgeSub=subHeaderTr.querySelector('.day-total');
                const ptsText=subHeaderTr.querySelector('.pts-text');
                const isExpanded = arrowSpan.textContent==='‚ñº';
                if(isExpanded){
                    badgeHeader.style.visibility='hidden';
                    badgeSub.style.display='inline-block';
                    if(ptsText) ptsText.style.display='none';
                } else {
                    badgeHeader.style.visibility='visible';
                    badgeSub.style.display='none';
                    if(ptsText) ptsText.style.display='inline';
                }
            });

            // Estado inicial
            if(!isInitiallyOpen){
                toggleRows();
                const arrowSpan=headerTr.querySelector('.arrow');
                if(arrowSpan){ arrowSpan.textContent='‚ñ∂'; }
                updateBadges(false);
            } else {
                updateBadges(true);
            }
        });
    }

    // Relocalizar el selector fecha/grupo fuera del bloque colapsable
    document.addEventListener('DOMContentLoaded',()=>{
      const viewSwitch=document.getElementById('groupStageViewSwitch');
      const firstPredSection=document.querySelector('.predictions-section');
      if(viewSwitch && firstPredSection && firstPredSection.parentElement){
        firstPredSection.parentElement.insertBefore(viewSwitch, firstPredSection);
        // Ajuste de estilo tras moverlo
        viewSwitch.style.marginTop='20px';
      }
    });

    // Render KO predictions agrupadas por fase
    function renderPredTablePhase(predArray, tbody){
        tbody.innerHTML='';
        const phaseMap={ ro16:"Round of 16", qf:"Quarter-Finals", sf:"Semi-Finals", final:"Final" };
        const order=["ro16","qf","sf","final"];

        // Agrupar predicciones por phase
        const groups={};
        predArray.forEach(p=>{
            const ph=matchesById[p.matchId]?.phase||'other';
            if(!groups[ph]) groups[ph]=[];
            groups[ph].push(p);
        });

        const calcPoints=(pred)=>{
            const res=resultsById[pred.matchId];
            if(res && res.homeGoals!==null){
                const diff=res.homeGoals-res.awayGoals;
                const predDiff=pred.predHome-pred.predAway;
                if(pred.predHome===res.homeGoals && pred.predAway===res.awayGoals) return 5;
                if((diff===0 && predDiff===0)||(diff>0 && predDiff>0)||(diff<0 && predDiff<0)) return 3;
            }
            return 0;
        };

        order.forEach(ph=>{
            if(!groups[ph]) return;
            const items=groups[ph].sort((a,b)=> new Date(matchesById[a.matchId].dateTime)-new Date(matchesById[b.matchId].dateTime));
            const ptsTotal=items.reduce((s,p)=>s+calcPoints(p),0);
            // Build team/unknown badges for phase header (similar a vista "By Date")
            const badgeArr=[];
            const pushBadge=(tok)=>{
                const idToken = teamIdToBadge[tok] ? tok : null;
                let src = 'badges/unknownTeam.png';
                if(idToken && teamIdToBadge[idToken]) src = teamIdToBadge[idToken];
                badgeArr.push(`<img src="${src}" class="team-badge" alt="team"/>`);
            };
            items.forEach(p=>{
                const m = matchesById[p.matchId];
                pushBadge(m.homeTeam);
                pushBadge(m.awayTeam);
            });
            const phaseBadgesHtml = badgeArr.join('');
            const headerTr=document.createElement('tr');
            headerTr.className='day-header';
            headerTr.innerHTML=`<td colspan="8"><div class="day-header-content"><span class="arrow">‚ñº</span><span class="date-text">${phaseMap[ph]}</span><span class="points-badge">${ptsTotal} pts</span></div><div class="phase-badges-row">${phaseBadgesHtml}</div></td>`;
            tbody.appendChild(headerTr);

            // subheader
            const sub=document.createElement('tr');
            sub.className='sub-header';
            const subHs=['Date','Time','ID','Pred.','Real','Pred.','Real','Pts'];
            sub.innerHTML = subHs.map((h,i)=> i===subHs.length-1 ? `<td class="pts-header-cell"><span class="day-total points-badge" style="display:none">${ptsTotal} pts</span><span class="pts-text">pts</span></td>`:`<td>${h}</td>`).join('');
            tbody.appendChild(sub);

            items.forEach(pred=>{
                const matchInfo=matchesById[pred.matchId];
                const date=new Date(matchInfo.dateTime);
                const day=date.toLocaleString('en-GB',{day:'numeric',month:'short'});
                const time=date.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',hour12:false});
                const predScore=`${pred.predHome}-${pred.predAway}`;
                const res=resultsById[pred.matchId];
                const realScore=res && res.homeGoals!==null?`${res.homeGoals}-${res.awayGoals}`:'-';
                const points=calcPoints(pred);
                const ptsClass=!res? 'none': points>0?'earned':'zero';
                const ptsText=res? points: '-';
                const row=document.createElement('tr');
                // build de celda con distinci√≥n entre columna Predicci√≥n y Real
                const buildCell=(tok, resolved, isReal = false)=>{
                    let id = getIdFromToken(tok);
                    // Si es columna Real y el token es placeholder (1A/2B/Wxx), forzar unknown
                    if(isReal && (/^[12][A-H]$/i.test(tok) || /^W\d+/i.test(tok))){
                        id = null;
                    }
                    // Para Pred., si no encontramos id con el token original pero resolved es distinto, reintentar con resolved
                    if(!id && resolved !== tok && !isReal){
                        id = getIdFromToken(resolved);
                    }
                    let src = 'badges/unknownTeam.png';
                    if(id && teamIdToBadge[id]){ src = teamIdToBadge[id]; }
                    const badge = `<img src="${src}" class="team-badge" alt="${resolved} badge"/>`;
                    const idText = tok;
                    return `${badge}<span class="team-id">${idText}</span><span class="team-name-full">${resolved}</span>`;
                };
                const predNames=`<span class="home-team">${buildCell(matchInfo.homeTeam, resolveUserToken(matchInfo.homeTeam), false)}</span><span class="vs-sep">vs</span><span class="away-team">${buildCell(matchInfo.awayTeam, resolveUserToken(matchInfo.awayTeam), false)}</span>`;
                const realNames=`<span class="home-team">${buildCell(matchInfo.homeTeam, resolveTeamToken(matchInfo.homeTeam), true)}</span><span class="vs-sep">vs</span><span class="away-team">${buildCell(matchInfo.awayTeam, resolveTeamToken(matchInfo.awayTeam), true)}</span>`;
                row.innerHTML=`<td class="round-cell">${day}</td><td class="time-cell">${time}</td><td class="round-cell">${matchInfo.matchId}</td><td class="match-cell">${predNames}</td><td class="match-cell">${realNames}</td><td class="score-cell prediction">${predScore}</td><td class="score-cell result">${realScore}</td><td class="points-cell"><span class="points-badge ${ptsClass}">${ptsText}</span></td>`;
                tbody.appendChild(row);
            });
            // toggle collapse
            const toggle=()=>{
                let n=headerTr.nextElementSibling;
                while(n && !n.classList.contains('day-header')){ n.style.display = n.style.display==='none'? '':'none'; n=n.nextElementSibling; }
            };
            headerTr.addEventListener('click',()=>{
                toggle();
                const arr=headerTr.querySelector('.arrow');
                if(arr) arr.textContent= arr.textContent==='‚ñº'?'‚ñ∂':'‚ñº';
                const expandedNow = arr.textContent==='‚ñº';
                const badgesRow=headerTr.querySelector('.phase-badges-row');
                if(badgesRow){ badgesRow.style.display = expandedNow? 'none' : 'flex'; }
                updatePts(expandedNow);
            });
        });
    }

    // Funci√≥n local para manejar traslado de puntos
    const updatePts = (expanded)=>{
        const badgeHeader=headerTr.querySelector('.points-badge');
        const badgeSub=sub.querySelector('.day-total');
        const ptsText=sub.querySelector('.pts-text');
        if(expanded){
            badgeHeader.style.visibility='hidden';
            badgeSub.style.display='inline-block';
            if(ptsText) ptsText.style.display='none';
        } else {
            badgeHeader.style.visibility='visible';
            badgeSub.style.display='none';
            if(ptsText) ptsText.style.display='inline';
        }
    };

    /* --------------------------------------------------
       UTILIDAD: Insertar / retirar icono "Live" en headers
    --------------------------------------------------*/
    function setLiveIconOnHeader(headerEl, isLive){
      if(!headerEl) return;
      let badge = headerEl.querySelector('.live-icon');
      if(isLive){
        if(!badge){
          badge=document.createElement('img');
          badge.src='live.svg';
          badge.alt='Live';
          badge.className='badge-icon live-icon';
          // Colocamos el icono justo despu√©s del t√≠tulo del header
          const titleEl = headerEl.querySelector('.section-title') || headerEl.querySelector('h2') || headerEl.querySelector('h3');
          if(titleEl){
            titleEl.insertAdjacentElement('afterend', badge);
          } else {
            headerEl.appendChild(badge);
          }
        }
      } else {
        if(badge){ badge.remove(); }
      }
    }

    function refreshHeaderLiveIcons(){
      // Determinar si hay iconos live en los cuerpos de cada secci√≥n
      const hasGroupLive = !!(groupPredictionsBody && groupPredictionsBody.querySelector('.live-icon'));
      const hasKOLive = !!(koPredictionsBody && koPredictionsBody.querySelector('.live-icon'));
      const hasClassifLive = !!(standingsContainer && standingsContainer.querySelector('.live-icon'));

      setLiveIconOnHeader(document.getElementById('groupPredHeader'), hasGroupLive);
      setLiveIconOnHeader(document.getElementById('koPredHeader'), hasKOLive);
      setLiveIconOnHeader(document.getElementById('classifHeader'), hasClassifLive);
    }
  </script>
</body>
</html>
